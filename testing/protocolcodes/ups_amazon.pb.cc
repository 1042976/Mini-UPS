// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ups_amazon.proto

#include "ups_amazon.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR U2AConnect::U2AConnect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.worldid_)*/int64_t{0}} {}
struct U2AConnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR U2AConnectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~U2AConnectDefaultTypeInternal() {}
  union {
    U2AConnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 U2AConnectDefaultTypeInternal _U2AConnect_default_instance_;
PROTOBUF_CONSTEXPR A2UConnected::A2UConnected(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.worldid_)*/int64_t{0}} {}
struct A2UConnectedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR A2UConnectedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~A2UConnectedDefaultTypeInternal() {}
  union {
    A2UConnected _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 A2UConnectedDefaultTypeInternal _A2UConnected_default_instance_;
PROTOBUF_CONSTEXPR A2UAskTruck::A2UAskTruck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.package_)*/{}
  , /*decltype(_impl_.warehouse_)*/nullptr
  , /*decltype(_impl_.seqnum_)*/int64_t{0}} {}
struct A2UAskTruckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR A2UAskTruckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~A2UAskTruckDefaultTypeInternal() {}
  union {
    A2UAskTruck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 A2UAskTruckDefaultTypeInternal _A2UAskTruck_default_instance_;
PROTOBUF_CONSTEXPR A2UPacked::A2UPacked(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.seqnum_)*/int64_t{0}
  , /*decltype(_impl_.shipid_)*/int64_t{0}} {}
struct A2UPackedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR A2UPackedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~A2UPackedDefaultTypeInternal() {}
  union {
    A2UPacked _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 A2UPackedDefaultTypeInternal _A2UPacked_default_instance_;
PROTOBUF_CONSTEXPR A2ULoading::A2ULoading(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.warehouse_)*/nullptr
  , /*decltype(_impl_.seqnum_)*/int64_t{0}
  , /*decltype(_impl_.truckid_)*/0} {}
struct A2ULoadingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR A2ULoadingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~A2ULoadingDefaultTypeInternal() {}
  union {
    A2ULoading _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 A2ULoadingDefaultTypeInternal _A2ULoading_default_instance_;
PROTOBUF_CONSTEXPR A2ULoaded::A2ULoaded(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.warehouse_)*/nullptr
  , /*decltype(_impl_.seqnum_)*/int64_t{0}
  , /*decltype(_impl_.truckid_)*/0} {}
struct A2ULoadedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR A2ULoadedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~A2ULoadedDefaultTypeInternal() {}
  union {
    A2ULoaded _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 A2ULoadedDefaultTypeInternal _A2ULoaded_default_instance_;
PROTOBUF_CONSTEXPR U2ATruckArrived::U2ATruckArrived(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.shipid_)*/{}
  , /*decltype(_impl_.warehouse_)*/nullptr
  , /*decltype(_impl_.seqnum_)*/int64_t{0}
  , /*decltype(_impl_.truckid_)*/0} {}
struct U2ATruckArrivedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR U2ATruckArrivedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~U2ATruckArrivedDefaultTypeInternal() {}
  union {
    U2ATruckArrived _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 U2ATruckArrivedDefaultTypeInternal _U2ATruckArrived_default_instance_;
PROTOBUF_CONSTEXPR U2ADelivering::U2ADelivering(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.shipid_)*/{}
  , /*decltype(_impl_.seqnum_)*/int64_t{0}
  , /*decltype(_impl_.truckid_)*/0} {}
struct U2ADeliveringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR U2ADeliveringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~U2ADeliveringDefaultTypeInternal() {}
  union {
    U2ADelivering _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 U2ADeliveringDefaultTypeInternal _U2ADelivering_default_instance_;
PROTOBUF_CONSTEXPR U2ADelivered::U2ADelivered(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.shipid_)*/{}
  , /*decltype(_impl_.seqnum_)*/int64_t{0}} {}
struct U2ADeliveredDefaultTypeInternal {
  PROTOBUF_CONSTEXPR U2ADeliveredDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~U2ADeliveredDefaultTypeInternal() {}
  union {
    U2ADelivered _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 U2ADeliveredDefaultTypeInternal _U2ADelivered_default_instance_;
PROTOBUF_CONSTEXPR PackageInfo::PackageInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.product_)*/{}
  , /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.shipid_)*/int64_t{0}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct PackageInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PackageInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PackageInfoDefaultTypeInternal() {}
  union {
    PackageInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PackageInfoDefaultTypeInternal _PackageInfo_default_instance_;
PROTOBUF_CONSTEXPR Product::Product(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.count_)*/0} {}
struct ProductDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProductDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProductDefaultTypeInternal() {}
  union {
    Product _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProductDefaultTypeInternal _Product_default_instance_;
PROTOBUF_CONSTEXPR Warehouse::Warehouse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.warehouseid_)*/0
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct WarehouseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WarehouseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WarehouseDefaultTypeInternal() {}
  union {
    Warehouse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WarehouseDefaultTypeInternal _Warehouse_default_instance_;
PROTOBUF_CONSTEXPR Error::Error(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.seqnum_)*/int64_t{0}
  , /*decltype(_impl_.originseqnum_)*/int64_t{0}} {}
struct ErrorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ErrorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ErrorDefaultTypeInternal() {}
  union {
    Error _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ErrorDefaultTypeInternal _Error_default_instance_;
PROTOBUF_CONSTEXPR A2UQueryShip::A2UQueryShip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.seqnum_)*/int64_t{0}
  , /*decltype(_impl_.shipid_)*/int64_t{0}} {}
struct A2UQueryShipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR A2UQueryShipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~A2UQueryShipDefaultTypeInternal() {}
  union {
    A2UQueryShip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 A2UQueryShipDefaultTypeInternal _A2UQueryShip_default_instance_;
PROTOBUF_CONSTEXPR U2AShipStatus::U2AShipStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.seqnum_)*/int64_t{0}
  , /*decltype(_impl_.shipid_)*/int64_t{0}} {}
struct U2AShipStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR U2AShipStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~U2AShipStatusDefaultTypeInternal() {}
  union {
    U2AShipStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 U2AShipStatusDefaultTypeInternal _U2AShipStatus_default_instance_;
PROTOBUF_CONSTEXPR U2AChangeAddress::U2AChangeAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.seqnum_)*/int64_t{0}
  , /*decltype(_impl_.shipid_)*/int64_t{0}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct U2AChangeAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR U2AChangeAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~U2AChangeAddressDefaultTypeInternal() {}
  union {
    U2AChangeAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 U2AChangeAddressDefaultTypeInternal _U2AChangeAddress_default_instance_;
PROTOBUF_CONSTEXPR AmazonCommands::AmazonCommands(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gettruck_)*/{}
  , /*decltype(_impl_.packed_)*/{}
  , /*decltype(_impl_.loading_)*/{}
  , /*decltype(_impl_.loaded_)*/{}
  , /*decltype(_impl_.query_)*/{}
  , /*decltype(_impl_.error_)*/{}
  , /*decltype(_impl_.acks_)*/{}
  , /*decltype(_impl_.finish_)*/false} {}
struct AmazonCommandsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AmazonCommandsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AmazonCommandsDefaultTypeInternal() {}
  union {
    AmazonCommands _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AmazonCommandsDefaultTypeInternal _AmazonCommands_default_instance_;
PROTOBUF_CONSTEXPR UPSCommands::UPSCommands(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.arrived_)*/{}
  , /*decltype(_impl_.delivering_)*/{}
  , /*decltype(_impl_.delivered_)*/{}
  , /*decltype(_impl_.status_)*/{}
  , /*decltype(_impl_.address_)*/{}
  , /*decltype(_impl_.error_)*/{}
  , /*decltype(_impl_.acks_)*/{}
  , /*decltype(_impl_.finish_)*/false} {}
struct UPSCommandsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UPSCommandsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UPSCommandsDefaultTypeInternal() {}
  union {
    UPSCommands _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UPSCommandsDefaultTypeInternal _UPSCommands_default_instance_;
static ::_pb::Metadata file_level_metadata_ups_5famazon_2eproto[18];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_ups_5famazon_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_ups_5famazon_2eproto = nullptr;

const uint32_t TableStruct_ups_5famazon_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::U2AConnect, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::U2AConnect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::U2AConnect, _impl_.worldid_),
  0,
  PROTOBUF_FIELD_OFFSET(::A2UConnected, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::A2UConnected, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::A2UConnected, _impl_.worldid_),
  PROTOBUF_FIELD_OFFSET(::A2UConnected, _impl_.result_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::A2UAskTruck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::A2UAskTruck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::A2UAskTruck, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::A2UAskTruck, _impl_.warehouse_),
  PROTOBUF_FIELD_OFFSET(::A2UAskTruck, _impl_.package_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::A2UPacked, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::A2UPacked, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::A2UPacked, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::A2UPacked, _impl_.shipid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::A2ULoading, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::A2ULoading, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::A2ULoading, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::A2ULoading, _impl_.warehouse_),
  PROTOBUF_FIELD_OFFSET(::A2ULoading, _impl_.truckid_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::A2ULoaded, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::A2ULoaded, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::A2ULoaded, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::A2ULoaded, _impl_.warehouse_),
  PROTOBUF_FIELD_OFFSET(::A2ULoaded, _impl_.truckid_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::U2ATruckArrived, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::U2ATruckArrived, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::U2ATruckArrived, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::U2ATruckArrived, _impl_.warehouse_),
  PROTOBUF_FIELD_OFFSET(::U2ATruckArrived, _impl_.truckid_),
  PROTOBUF_FIELD_OFFSET(::U2ATruckArrived, _impl_.shipid_),
  1,
  0,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::U2ADelivering, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::U2ADelivering, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::U2ADelivering, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::U2ADelivering, _impl_.shipid_),
  PROTOBUF_FIELD_OFFSET(::U2ADelivering, _impl_.truckid_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::U2ADelivered, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::U2ADelivered, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::U2ADelivered, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::U2ADelivered, _impl_.shipid_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::PackageInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::PackageInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PackageInfo, _impl_.shipid_),
  PROTOBUF_FIELD_OFFSET(::PackageInfo, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::PackageInfo, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::PackageInfo, _impl_.user_name_),
  PROTOBUF_FIELD_OFFSET(::PackageInfo, _impl_.product_),
  1,
  2,
  3,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Product, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Product, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Product, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::Product, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::Product, _impl_.count_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::Warehouse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Warehouse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Warehouse, _impl_.warehouseid_),
  PROTOBUF_FIELD_OFFSET(::Warehouse, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::Warehouse, _impl_.y_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::Error, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Error, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Error, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::Error, _impl_.originseqnum_),
  PROTOBUF_FIELD_OFFSET(::Error, _impl_.info_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::A2UQueryShip, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::A2UQueryShip, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::A2UQueryShip, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::A2UQueryShip, _impl_.shipid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::U2AShipStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::U2AShipStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::U2AShipStatus, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::U2AShipStatus, _impl_.shipid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::U2AChangeAddress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::U2AChangeAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::U2AChangeAddress, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::U2AChangeAddress, _impl_.shipid_),
  PROTOBUF_FIELD_OFFSET(::U2AChangeAddress, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::U2AChangeAddress, _impl_.y_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::AmazonCommands, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::AmazonCommands, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AmazonCommands, _impl_.gettruck_),
  PROTOBUF_FIELD_OFFSET(::AmazonCommands, _impl_.packed_),
  PROTOBUF_FIELD_OFFSET(::AmazonCommands, _impl_.loading_),
  PROTOBUF_FIELD_OFFSET(::AmazonCommands, _impl_.loaded_),
  PROTOBUF_FIELD_OFFSET(::AmazonCommands, _impl_.query_),
  PROTOBUF_FIELD_OFFSET(::AmazonCommands, _impl_.error_),
  PROTOBUF_FIELD_OFFSET(::AmazonCommands, _impl_.acks_),
  PROTOBUF_FIELD_OFFSET(::AmazonCommands, _impl_.finish_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::UPSCommands, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::UPSCommands, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UPSCommands, _impl_.arrived_),
  PROTOBUF_FIELD_OFFSET(::UPSCommands, _impl_.delivering_),
  PROTOBUF_FIELD_OFFSET(::UPSCommands, _impl_.delivered_),
  PROTOBUF_FIELD_OFFSET(::UPSCommands, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::UPSCommands, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::UPSCommands, _impl_.error_),
  PROTOBUF_FIELD_OFFSET(::UPSCommands, _impl_.acks_),
  PROTOBUF_FIELD_OFFSET(::UPSCommands, _impl_.finish_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::U2AConnect)},
  { 8, 16, -1, sizeof(::A2UConnected)},
  { 18, 27, -1, sizeof(::A2UAskTruck)},
  { 30, 38, -1, sizeof(::A2UPacked)},
  { 40, 49, -1, sizeof(::A2ULoading)},
  { 52, 61, -1, sizeof(::A2ULoaded)},
  { 64, 74, -1, sizeof(::U2ATruckArrived)},
  { 78, 87, -1, sizeof(::U2ADelivering)},
  { 90, 98, -1, sizeof(::U2ADelivered)},
  { 100, 111, -1, sizeof(::PackageInfo)},
  { 116, 125, -1, sizeof(::Product)},
  { 128, 137, -1, sizeof(::Warehouse)},
  { 140, 149, -1, sizeof(::Error)},
  { 152, 160, -1, sizeof(::A2UQueryShip)},
  { 162, 170, -1, sizeof(::U2AShipStatus)},
  { 172, 182, -1, sizeof(::U2AChangeAddress)},
  { 186, 200, -1, sizeof(::AmazonCommands)},
  { 208, 222, -1, sizeof(::UPSCommands)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_U2AConnect_default_instance_._instance,
  &::_A2UConnected_default_instance_._instance,
  &::_A2UAskTruck_default_instance_._instance,
  &::_A2UPacked_default_instance_._instance,
  &::_A2ULoading_default_instance_._instance,
  &::_A2ULoaded_default_instance_._instance,
  &::_U2ATruckArrived_default_instance_._instance,
  &::_U2ADelivering_default_instance_._instance,
  &::_U2ADelivered_default_instance_._instance,
  &::_PackageInfo_default_instance_._instance,
  &::_Product_default_instance_._instance,
  &::_Warehouse_default_instance_._instance,
  &::_Error_default_instance_._instance,
  &::_A2UQueryShip_default_instance_._instance,
  &::_U2AShipStatus_default_instance_._instance,
  &::_U2AChangeAddress_default_instance_._instance,
  &::_AmazonCommands_default_instance_._instance,
  &::_UPSCommands_default_instance_._instance,
};

const char descriptor_table_protodef_ups_5famazon_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020ups_amazon.proto\"\035\n\nU2AConnect\022\017\n\007worl"
  "did\030\001 \002(\003\"/\n\014A2UConnected\022\017\n\007worldid\030\001 \002"
  "(\003\022\016\n\006result\030\002 \002(\t\"[\n\013A2UAskTruck\022\016\n\006seq"
  "num\030\001 \002(\003\022\035\n\twarehouse\030\002 \002(\0132\n.Warehouse"
  "\022\035\n\007package\030\003 \003(\0132\014.PackageInfo\"+\n\tA2UPa"
  "cked\022\016\n\006seqnum\030\001 \002(\003\022\016\n\006shipid\030\002 \002(\003\"L\n\n"
  "A2ULoading\022\016\n\006seqnum\030\001 \002(\003\022\035\n\twarehouse\030"
  "\002 \002(\0132\n.Warehouse\022\017\n\007truckid\030\003 \002(\005\"K\n\tA2"
  "ULoaded\022\016\n\006seqnum\030\001 \002(\003\022\035\n\twarehouse\030\002 \002"
  "(\0132\n.Warehouse\022\017\n\007truckid\030\003 \002(\005\"a\n\017U2ATr"
  "uckArrived\022\016\n\006seqnum\030\001 \002(\003\022\035\n\twarehouse\030"
  "\002 \002(\0132\n.Warehouse\022\017\n\007truckid\030\003 \002(\005\022\016\n\006sh"
  "ipid\030\004 \003(\003\"@\n\rU2ADelivering\022\016\n\006seqnum\030\001 "
  "\002(\003\022\016\n\006shipid\030\002 \003(\003\022\017\n\007truckid\030\003 \002(\005\".\n\014"
  "U2ADelivered\022\016\n\006seqnum\030\001 \002(\003\022\016\n\006shipid\030\002"
  " \003(\003\"a\n\013PackageInfo\022\016\n\006shipid\030\001 \002(\003\022\t\n\001x"
  "\030\002 \002(\005\022\t\n\001y\030\003 \002(\005\022\021\n\tuser_name\030\004 \001(\t\022\031\n\007"
  "product\030\005 \003(\0132\010.Product\";\n\007Product\022\014\n\004na"
  "me\030\001 \002(\t\022\023\n\013description\030\002 \002(\t\022\r\n\005count\030\003"
  " \002(\005\"6\n\tWarehouse\022\023\n\013warehouseid\030\001 \002(\005\022\t"
  "\n\001x\030\002 \002(\005\022\t\n\001y\030\003 \002(\005\";\n\005Error\022\016\n\006seqnum\030"
  "\001 \002(\003\022\024\n\014originseqnum\030\002 \002(\003\022\014\n\004info\030\003 \001("
  "\t\".\n\014A2UQueryShip\022\016\n\006seqnum\030\001 \002(\003\022\016\n\006shi"
  "pid\030\002 \002(\003\"/\n\rU2AShipStatus\022\016\n\006seqnum\030\001 \002"
  "(\003\022\016\n\006shipid\030\002 \002(\003\"H\n\020U2AChangeAddress\022\016"
  "\n\006seqnum\030\001 \002(\003\022\016\n\006shipid\030\002 \002(\003\022\t\n\001x\030\003 \002("
  "\005\022\t\n\001y\030\004 \002(\005\"\331\001\n\016AmazonCommands\022\036\n\010getTr"
  "uck\030\001 \003(\0132\014.A2UAskTruck\022\032\n\006packed\030\002 \003(\0132"
  "\n.A2UPacked\022\034\n\007loading\030\003 \003(\0132\013.A2ULoadin"
  "g\022\032\n\006loaded\030\004 \003(\0132\n.A2ULoaded\022\034\n\005query\030\005"
  " \003(\0132\r.A2UQueryShip\022\025\n\005error\030\006 \003(\0132\006.Err"
  "or\022\014\n\004acks\030\007 \003(\003\022\016\n\006finish\030\010 \001(\010\"\357\001\n\013UPS"
  "Commands\022!\n\007arrived\030\001 \003(\0132\020.U2ATruckArri"
  "ved\022\"\n\ndelivering\030\002 \003(\0132\016.U2ADelivering\022"
  " \n\tdelivered\030\003 \003(\0132\r.U2ADelivered\022\036\n\006sta"
  "tus\030\004 \003(\0132\016.U2AShipStatus\022\"\n\007address\030\005 \003"
  "(\0132\021.U2AChangeAddress\022\025\n\005error\030\006 \003(\0132\006.E"
  "rror\022\014\n\004acks\030\007 \003(\003\022\016\n\006finish\030\010 \001(\010"
  ;
static ::_pbi::once_flag descriptor_table_ups_5famazon_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_ups_5famazon_2eproto = {
    false, false, 1514, descriptor_table_protodef_ups_5famazon_2eproto,
    "ups_amazon.proto",
    &descriptor_table_ups_5famazon_2eproto_once, nullptr, 0, 18,
    schemas, file_default_instances, TableStruct_ups_5famazon_2eproto::offsets,
    file_level_metadata_ups_5famazon_2eproto, file_level_enum_descriptors_ups_5famazon_2eproto,
    file_level_service_descriptors_ups_5famazon_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ups_5famazon_2eproto_getter() {
  return &descriptor_table_ups_5famazon_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ups_5famazon_2eproto(&descriptor_table_ups_5famazon_2eproto);

// ===================================================================

class U2AConnect::_Internal {
 public:
  using HasBits = decltype(std::declval<U2AConnect>()._impl_._has_bits_);
  static void set_has_worldid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

U2AConnect::U2AConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:U2AConnect)
}
U2AConnect::U2AConnect(const U2AConnect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.worldid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.worldid_ = from._impl_.worldid_;
  // @@protoc_insertion_point(copy_constructor:U2AConnect)
}

inline void U2AConnect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.worldid_){int64_t{0}}
  };
}

U2AConnect::~U2AConnect() {
  // @@protoc_insertion_point(destructor:U2AConnect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void U2AConnect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void U2AConnect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void U2AConnect::Clear() {
// @@protoc_insertion_point(message_clear_start:U2AConnect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.worldid_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* U2AConnect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 worldid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_worldid(&has_bits);
          _impl_.worldid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* U2AConnect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:U2AConnect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 worldid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_worldid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:U2AConnect)
  return target;
}

size_t U2AConnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:U2AConnect)
  size_t total_size = 0;

  // required int64 worldid = 1;
  if (_internal_has_worldid()) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_worldid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData U2AConnect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    U2AConnect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*U2AConnect::GetClassData() const { return &_class_data_; }

void U2AConnect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<U2AConnect *>(to)->MergeFrom(
      static_cast<const U2AConnect &>(from));
}


void U2AConnect::MergeFrom(const U2AConnect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:U2AConnect)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_worldid()) {
    _internal_set_worldid(from._internal_worldid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void U2AConnect::CopyFrom(const U2AConnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:U2AConnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool U2AConnect::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void U2AConnect::InternalSwap(U2AConnect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.worldid_, other->_impl_.worldid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata U2AConnect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[0]);
}

// ===================================================================

class A2UConnected::_Internal {
 public:
  using HasBits = decltype(std::declval<A2UConnected>()._impl_._has_bits_);
  static void set_has_worldid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

A2UConnected::A2UConnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:A2UConnected)
}
A2UConnected::A2UConnected(const A2UConnected& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}
    , decltype(_impl_.worldid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.result_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.result_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_result()) {
    _impl_.result_.Set(from._internal_result(), 
      GetArenaForAllocation());
  }
  _impl_.worldid_ = from._impl_.worldid_;
  // @@protoc_insertion_point(copy_constructor:A2UConnected)
}

inline void A2UConnected::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}
    , decltype(_impl_.worldid_){int64_t{0}}
  };
  _impl_.result_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.result_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

A2UConnected::~A2UConnected() {
  // @@protoc_insertion_point(destructor:A2UConnected)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void A2UConnected::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.result_.Destroy();
}

void A2UConnected::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void A2UConnected::Clear() {
// @@protoc_insertion_point(message_clear_start:A2UConnected)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.result_.ClearNonDefaultToEmpty();
  }
  _impl_.worldid_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* A2UConnected::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 worldid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_worldid(&has_bits);
          _impl_.worldid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_result();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "A2UConnected.result");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* A2UConnected::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A2UConnected)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 worldid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_worldid(), target);
  }

  // required string result = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_result().data(), static_cast<int>(this->_internal_result().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "A2UConnected.result");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A2UConnected)
  return target;
}

size_t A2UConnected::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:A2UConnected)
  size_t total_size = 0;

  if (_internal_has_result()) {
    // required string result = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_result());
  }

  if (_internal_has_worldid()) {
    // required int64 worldid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_worldid());
  }

  return total_size;
}
size_t A2UConnected::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A2UConnected)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string result = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_result());

    // required int64 worldid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_worldid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData A2UConnected::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    A2UConnected::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*A2UConnected::GetClassData() const { return &_class_data_; }

void A2UConnected::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<A2UConnected *>(to)->MergeFrom(
      static_cast<const A2UConnected &>(from));
}


void A2UConnected::MergeFrom(const A2UConnected& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:A2UConnected)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_result(from._internal_result());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.worldid_ = from._impl_.worldid_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void A2UConnected::CopyFrom(const A2UConnected& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A2UConnected)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool A2UConnected::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void A2UConnected::InternalSwap(A2UConnected* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.result_, lhs_arena,
      &other->_impl_.result_, rhs_arena
  );
  swap(_impl_.worldid_, other->_impl_.worldid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata A2UConnected::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[1]);
}

// ===================================================================

class A2UAskTruck::_Internal {
 public:
  using HasBits = decltype(std::declval<A2UAskTruck>()._impl_._has_bits_);
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Warehouse& warehouse(const A2UAskTruck* msg);
  static void set_has_warehouse(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::Warehouse&
A2UAskTruck::_Internal::warehouse(const A2UAskTruck* msg) {
  return *msg->_impl_.warehouse_;
}
A2UAskTruck::A2UAskTruck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:A2UAskTruck)
}
A2UAskTruck::A2UAskTruck(const A2UAskTruck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.package_){from._impl_.package_}
    , decltype(_impl_.warehouse_){nullptr}
    , decltype(_impl_.seqnum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_warehouse()) {
    _impl_.warehouse_ = new ::Warehouse(*from._impl_.warehouse_);
  }
  _impl_.seqnum_ = from._impl_.seqnum_;
  // @@protoc_insertion_point(copy_constructor:A2UAskTruck)
}

inline void A2UAskTruck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.package_){arena}
    , decltype(_impl_.warehouse_){nullptr}
    , decltype(_impl_.seqnum_){int64_t{0}}
  };
}

A2UAskTruck::~A2UAskTruck() {
  // @@protoc_insertion_point(destructor:A2UAskTruck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void A2UAskTruck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.package_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.warehouse_;
}

void A2UAskTruck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void A2UAskTruck::Clear() {
// @@protoc_insertion_point(message_clear_start:A2UAskTruck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.package_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.warehouse_ != nullptr);
    _impl_.warehouse_->Clear();
  }
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* A2UAskTruck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 seqnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Warehouse warehouse = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_warehouse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PackageInfo package = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_package(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* A2UAskTruck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A2UAskTruck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 seqnum = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seqnum(), target);
  }

  // required .Warehouse warehouse = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::warehouse(this),
        _Internal::warehouse(this).GetCachedSize(), target, stream);
  }

  // repeated .PackageInfo package = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_package_size()); i < n; i++) {
    const auto& repfield = this->_internal_package(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A2UAskTruck)
  return target;
}

size_t A2UAskTruck::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:A2UAskTruck)
  size_t total_size = 0;

  if (_internal_has_warehouse()) {
    // required .Warehouse warehouse = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.warehouse_);
  }

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  return total_size;
}
size_t A2UAskTruck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A2UAskTruck)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .Warehouse warehouse = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.warehouse_);

    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PackageInfo package = 3;
  total_size += 1UL * this->_internal_package_size();
  for (const auto& msg : this->_impl_.package_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData A2UAskTruck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    A2UAskTruck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*A2UAskTruck::GetClassData() const { return &_class_data_; }

void A2UAskTruck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<A2UAskTruck *>(to)->MergeFrom(
      static_cast<const A2UAskTruck &>(from));
}


void A2UAskTruck::MergeFrom(const A2UAskTruck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:A2UAskTruck)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.package_.MergeFrom(from._impl_.package_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_warehouse()->::Warehouse::MergeFrom(from._internal_warehouse());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.seqnum_ = from._impl_.seqnum_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void A2UAskTruck::CopyFrom(const A2UAskTruck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A2UAskTruck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool A2UAskTruck::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.package_))
    return false;
  if (_internal_has_warehouse()) {
    if (!_impl_.warehouse_->IsInitialized()) return false;
  }
  return true;
}

void A2UAskTruck::InternalSwap(A2UAskTruck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.package_.InternalSwap(&other->_impl_.package_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(A2UAskTruck, _impl_.seqnum_)
      + sizeof(A2UAskTruck::_impl_.seqnum_)
      - PROTOBUF_FIELD_OFFSET(A2UAskTruck, _impl_.warehouse_)>(
          reinterpret_cast<char*>(&_impl_.warehouse_),
          reinterpret_cast<char*>(&other->_impl_.warehouse_));
}

::PROTOBUF_NAMESPACE_ID::Metadata A2UAskTruck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[2]);
}

// ===================================================================

class A2UPacked::_Internal {
 public:
  using HasBits = decltype(std::declval<A2UPacked>()._impl_._has_bits_);
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_shipid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

A2UPacked::A2UPacked(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:A2UPacked)
}
A2UPacked::A2UPacked(const A2UPacked& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seqnum_){}
    , decltype(_impl_.shipid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.seqnum_, &from._impl_.seqnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shipid_) -
    reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.shipid_));
  // @@protoc_insertion_point(copy_constructor:A2UPacked)
}

inline void A2UPacked::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seqnum_){int64_t{0}}
    , decltype(_impl_.shipid_){int64_t{0}}
  };
}

A2UPacked::~A2UPacked() {
  // @@protoc_insertion_point(destructor:A2UPacked)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void A2UPacked::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void A2UPacked::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void A2UPacked::Clear() {
// @@protoc_insertion_point(message_clear_start:A2UPacked)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.seqnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shipid_) -
        reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.shipid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* A2UPacked::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 seqnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 shipid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_shipid(&has_bits);
          _impl_.shipid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* A2UPacked::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A2UPacked)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 seqnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seqnum(), target);
  }

  // required int64 shipid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_shipid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A2UPacked)
  return target;
}

size_t A2UPacked::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:A2UPacked)
  size_t total_size = 0;

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  if (_internal_has_shipid()) {
    // required int64 shipid = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());
  }

  return total_size;
}
size_t A2UPacked::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A2UPacked)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

    // required int64 shipid = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData A2UPacked::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    A2UPacked::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*A2UPacked::GetClassData() const { return &_class_data_; }

void A2UPacked::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<A2UPacked *>(to)->MergeFrom(
      static_cast<const A2UPacked &>(from));
}


void A2UPacked::MergeFrom(const A2UPacked& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:A2UPacked)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.seqnum_ = from._impl_.seqnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.shipid_ = from._impl_.shipid_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void A2UPacked::CopyFrom(const A2UPacked& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A2UPacked)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool A2UPacked::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void A2UPacked::InternalSwap(A2UPacked* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(A2UPacked, _impl_.shipid_)
      + sizeof(A2UPacked::_impl_.shipid_)
      - PROTOBUF_FIELD_OFFSET(A2UPacked, _impl_.seqnum_)>(
          reinterpret_cast<char*>(&_impl_.seqnum_),
          reinterpret_cast<char*>(&other->_impl_.seqnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata A2UPacked::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[3]);
}

// ===================================================================

class A2ULoading::_Internal {
 public:
  using HasBits = decltype(std::declval<A2ULoading>()._impl_._has_bits_);
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Warehouse& warehouse(const A2ULoading* msg);
  static void set_has_warehouse(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_truckid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::Warehouse&
A2ULoading::_Internal::warehouse(const A2ULoading* msg) {
  return *msg->_impl_.warehouse_;
}
A2ULoading::A2ULoading(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:A2ULoading)
}
A2ULoading::A2ULoading(const A2ULoading& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.warehouse_){nullptr}
    , decltype(_impl_.seqnum_){}
    , decltype(_impl_.truckid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_warehouse()) {
    _impl_.warehouse_ = new ::Warehouse(*from._impl_.warehouse_);
  }
  ::memcpy(&_impl_.seqnum_, &from._impl_.seqnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.truckid_) -
    reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.truckid_));
  // @@protoc_insertion_point(copy_constructor:A2ULoading)
}

inline void A2ULoading::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.warehouse_){nullptr}
    , decltype(_impl_.seqnum_){int64_t{0}}
    , decltype(_impl_.truckid_){0}
  };
}

A2ULoading::~A2ULoading() {
  // @@protoc_insertion_point(destructor:A2ULoading)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void A2ULoading::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.warehouse_;
}

void A2ULoading::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void A2ULoading::Clear() {
// @@protoc_insertion_point(message_clear_start:A2ULoading)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.warehouse_ != nullptr);
    _impl_.warehouse_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.seqnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.truckid_) -
        reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.truckid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* A2ULoading::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 seqnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Warehouse warehouse = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_warehouse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 truckid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_truckid(&has_bits);
          _impl_.truckid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* A2ULoading::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A2ULoading)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 seqnum = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seqnum(), target);
  }

  // required .Warehouse warehouse = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::warehouse(this),
        _Internal::warehouse(this).GetCachedSize(), target, stream);
  }

  // required int32 truckid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_truckid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A2ULoading)
  return target;
}

size_t A2ULoading::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:A2ULoading)
  size_t total_size = 0;

  if (_internal_has_warehouse()) {
    // required .Warehouse warehouse = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.warehouse_);
  }

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  if (_internal_has_truckid()) {
    // required int32 truckid = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_truckid());
  }

  return total_size;
}
size_t A2ULoading::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A2ULoading)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .Warehouse warehouse = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.warehouse_);

    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

    // required int32 truckid = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_truckid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData A2ULoading::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    A2ULoading::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*A2ULoading::GetClassData() const { return &_class_data_; }

void A2ULoading::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<A2ULoading *>(to)->MergeFrom(
      static_cast<const A2ULoading &>(from));
}


void A2ULoading::MergeFrom(const A2ULoading& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:A2ULoading)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_warehouse()->::Warehouse::MergeFrom(from._internal_warehouse());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.seqnum_ = from._impl_.seqnum_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.truckid_ = from._impl_.truckid_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void A2ULoading::CopyFrom(const A2ULoading& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A2ULoading)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool A2ULoading::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_warehouse()) {
    if (!_impl_.warehouse_->IsInitialized()) return false;
  }
  return true;
}

void A2ULoading::InternalSwap(A2ULoading* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(A2ULoading, _impl_.truckid_)
      + sizeof(A2ULoading::_impl_.truckid_)
      - PROTOBUF_FIELD_OFFSET(A2ULoading, _impl_.warehouse_)>(
          reinterpret_cast<char*>(&_impl_.warehouse_),
          reinterpret_cast<char*>(&other->_impl_.warehouse_));
}

::PROTOBUF_NAMESPACE_ID::Metadata A2ULoading::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[4]);
}

// ===================================================================

class A2ULoaded::_Internal {
 public:
  using HasBits = decltype(std::declval<A2ULoaded>()._impl_._has_bits_);
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Warehouse& warehouse(const A2ULoaded* msg);
  static void set_has_warehouse(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_truckid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::Warehouse&
A2ULoaded::_Internal::warehouse(const A2ULoaded* msg) {
  return *msg->_impl_.warehouse_;
}
A2ULoaded::A2ULoaded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:A2ULoaded)
}
A2ULoaded::A2ULoaded(const A2ULoaded& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.warehouse_){nullptr}
    , decltype(_impl_.seqnum_){}
    , decltype(_impl_.truckid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_warehouse()) {
    _impl_.warehouse_ = new ::Warehouse(*from._impl_.warehouse_);
  }
  ::memcpy(&_impl_.seqnum_, &from._impl_.seqnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.truckid_) -
    reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.truckid_));
  // @@protoc_insertion_point(copy_constructor:A2ULoaded)
}

inline void A2ULoaded::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.warehouse_){nullptr}
    , decltype(_impl_.seqnum_){int64_t{0}}
    , decltype(_impl_.truckid_){0}
  };
}

A2ULoaded::~A2ULoaded() {
  // @@protoc_insertion_point(destructor:A2ULoaded)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void A2ULoaded::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.warehouse_;
}

void A2ULoaded::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void A2ULoaded::Clear() {
// @@protoc_insertion_point(message_clear_start:A2ULoaded)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.warehouse_ != nullptr);
    _impl_.warehouse_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.seqnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.truckid_) -
        reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.truckid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* A2ULoaded::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 seqnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Warehouse warehouse = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_warehouse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 truckid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_truckid(&has_bits);
          _impl_.truckid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* A2ULoaded::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A2ULoaded)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 seqnum = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seqnum(), target);
  }

  // required .Warehouse warehouse = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::warehouse(this),
        _Internal::warehouse(this).GetCachedSize(), target, stream);
  }

  // required int32 truckid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_truckid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A2ULoaded)
  return target;
}

size_t A2ULoaded::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:A2ULoaded)
  size_t total_size = 0;

  if (_internal_has_warehouse()) {
    // required .Warehouse warehouse = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.warehouse_);
  }

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  if (_internal_has_truckid()) {
    // required int32 truckid = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_truckid());
  }

  return total_size;
}
size_t A2ULoaded::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A2ULoaded)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .Warehouse warehouse = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.warehouse_);

    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

    // required int32 truckid = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_truckid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData A2ULoaded::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    A2ULoaded::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*A2ULoaded::GetClassData() const { return &_class_data_; }

void A2ULoaded::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<A2ULoaded *>(to)->MergeFrom(
      static_cast<const A2ULoaded &>(from));
}


void A2ULoaded::MergeFrom(const A2ULoaded& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:A2ULoaded)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_warehouse()->::Warehouse::MergeFrom(from._internal_warehouse());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.seqnum_ = from._impl_.seqnum_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.truckid_ = from._impl_.truckid_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void A2ULoaded::CopyFrom(const A2ULoaded& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A2ULoaded)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool A2ULoaded::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_warehouse()) {
    if (!_impl_.warehouse_->IsInitialized()) return false;
  }
  return true;
}

void A2ULoaded::InternalSwap(A2ULoaded* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(A2ULoaded, _impl_.truckid_)
      + sizeof(A2ULoaded::_impl_.truckid_)
      - PROTOBUF_FIELD_OFFSET(A2ULoaded, _impl_.warehouse_)>(
          reinterpret_cast<char*>(&_impl_.warehouse_),
          reinterpret_cast<char*>(&other->_impl_.warehouse_));
}

::PROTOBUF_NAMESPACE_ID::Metadata A2ULoaded::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[5]);
}

// ===================================================================

class U2ATruckArrived::_Internal {
 public:
  using HasBits = decltype(std::declval<U2ATruckArrived>()._impl_._has_bits_);
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Warehouse& warehouse(const U2ATruckArrived* msg);
  static void set_has_warehouse(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_truckid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::Warehouse&
U2ATruckArrived::_Internal::warehouse(const U2ATruckArrived* msg) {
  return *msg->_impl_.warehouse_;
}
U2ATruckArrived::U2ATruckArrived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:U2ATruckArrived)
}
U2ATruckArrived::U2ATruckArrived(const U2ATruckArrived& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shipid_){from._impl_.shipid_}
    , decltype(_impl_.warehouse_){nullptr}
    , decltype(_impl_.seqnum_){}
    , decltype(_impl_.truckid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_warehouse()) {
    _impl_.warehouse_ = new ::Warehouse(*from._impl_.warehouse_);
  }
  ::memcpy(&_impl_.seqnum_, &from._impl_.seqnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.truckid_) -
    reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.truckid_));
  // @@protoc_insertion_point(copy_constructor:U2ATruckArrived)
}

inline void U2ATruckArrived::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shipid_){arena}
    , decltype(_impl_.warehouse_){nullptr}
    , decltype(_impl_.seqnum_){int64_t{0}}
    , decltype(_impl_.truckid_){0}
  };
}

U2ATruckArrived::~U2ATruckArrived() {
  // @@protoc_insertion_point(destructor:U2ATruckArrived)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void U2ATruckArrived::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.shipid_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.warehouse_;
}

void U2ATruckArrived::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void U2ATruckArrived::Clear() {
// @@protoc_insertion_point(message_clear_start:U2ATruckArrived)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.shipid_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.warehouse_ != nullptr);
    _impl_.warehouse_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.seqnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.truckid_) -
        reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.truckid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* U2ATruckArrived::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 seqnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Warehouse warehouse = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_warehouse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 truckid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_truckid(&has_bits);
          _impl_.truckid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 shipid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_shipid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_shipid(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* U2ATruckArrived::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:U2ATruckArrived)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 seqnum = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seqnum(), target);
  }

  // required .Warehouse warehouse = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::warehouse(this),
        _Internal::warehouse(this).GetCachedSize(), target, stream);
  }

  // required int32 truckid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_truckid(), target);
  }

  // repeated int64 shipid = 4;
  for (int i = 0, n = this->_internal_shipid_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_shipid(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:U2ATruckArrived)
  return target;
}

size_t U2ATruckArrived::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:U2ATruckArrived)
  size_t total_size = 0;

  if (_internal_has_warehouse()) {
    // required .Warehouse warehouse = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.warehouse_);
  }

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  if (_internal_has_truckid()) {
    // required int32 truckid = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_truckid());
  }

  return total_size;
}
size_t U2ATruckArrived::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:U2ATruckArrived)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .Warehouse warehouse = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.warehouse_);

    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

    // required int32 truckid = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_truckid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 shipid = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.shipid_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_shipid_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData U2ATruckArrived::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    U2ATruckArrived::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*U2ATruckArrived::GetClassData() const { return &_class_data_; }

void U2ATruckArrived::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<U2ATruckArrived *>(to)->MergeFrom(
      static_cast<const U2ATruckArrived &>(from));
}


void U2ATruckArrived::MergeFrom(const U2ATruckArrived& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:U2ATruckArrived)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.shipid_.MergeFrom(from._impl_.shipid_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_warehouse()->::Warehouse::MergeFrom(from._internal_warehouse());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.seqnum_ = from._impl_.seqnum_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.truckid_ = from._impl_.truckid_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void U2ATruckArrived::CopyFrom(const U2ATruckArrived& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:U2ATruckArrived)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool U2ATruckArrived::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_warehouse()) {
    if (!_impl_.warehouse_->IsInitialized()) return false;
  }
  return true;
}

void U2ATruckArrived::InternalSwap(U2ATruckArrived* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.shipid_.InternalSwap(&other->_impl_.shipid_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(U2ATruckArrived, _impl_.truckid_)
      + sizeof(U2ATruckArrived::_impl_.truckid_)
      - PROTOBUF_FIELD_OFFSET(U2ATruckArrived, _impl_.warehouse_)>(
          reinterpret_cast<char*>(&_impl_.warehouse_),
          reinterpret_cast<char*>(&other->_impl_.warehouse_));
}

::PROTOBUF_NAMESPACE_ID::Metadata U2ATruckArrived::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[6]);
}

// ===================================================================

class U2ADelivering::_Internal {
 public:
  using HasBits = decltype(std::declval<U2ADelivering>()._impl_._has_bits_);
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_truckid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

U2ADelivering::U2ADelivering(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:U2ADelivering)
}
U2ADelivering::U2ADelivering(const U2ADelivering& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shipid_){from._impl_.shipid_}
    , decltype(_impl_.seqnum_){}
    , decltype(_impl_.truckid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.seqnum_, &from._impl_.seqnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.truckid_) -
    reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.truckid_));
  // @@protoc_insertion_point(copy_constructor:U2ADelivering)
}

inline void U2ADelivering::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shipid_){arena}
    , decltype(_impl_.seqnum_){int64_t{0}}
    , decltype(_impl_.truckid_){0}
  };
}

U2ADelivering::~U2ADelivering() {
  // @@protoc_insertion_point(destructor:U2ADelivering)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void U2ADelivering::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.shipid_.~RepeatedField();
}

void U2ADelivering::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void U2ADelivering::Clear() {
// @@protoc_insertion_point(message_clear_start:U2ADelivering)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.shipid_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.seqnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.truckid_) -
        reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.truckid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* U2ADelivering::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 seqnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 shipid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_shipid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_shipid(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 truckid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_truckid(&has_bits);
          _impl_.truckid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* U2ADelivering::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:U2ADelivering)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 seqnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seqnum(), target);
  }

  // repeated int64 shipid = 2;
  for (int i = 0, n = this->_internal_shipid_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_shipid(i), target);
  }

  // required int32 truckid = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_truckid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:U2ADelivering)
  return target;
}

size_t U2ADelivering::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:U2ADelivering)
  size_t total_size = 0;

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  if (_internal_has_truckid()) {
    // required int32 truckid = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_truckid());
  }

  return total_size;
}
size_t U2ADelivering::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:U2ADelivering)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

    // required int32 truckid = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_truckid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 shipid = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.shipid_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_shipid_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData U2ADelivering::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    U2ADelivering::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*U2ADelivering::GetClassData() const { return &_class_data_; }

void U2ADelivering::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<U2ADelivering *>(to)->MergeFrom(
      static_cast<const U2ADelivering &>(from));
}


void U2ADelivering::MergeFrom(const U2ADelivering& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:U2ADelivering)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.shipid_.MergeFrom(from._impl_.shipid_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.seqnum_ = from._impl_.seqnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.truckid_ = from._impl_.truckid_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void U2ADelivering::CopyFrom(const U2ADelivering& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:U2ADelivering)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool U2ADelivering::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void U2ADelivering::InternalSwap(U2ADelivering* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.shipid_.InternalSwap(&other->_impl_.shipid_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(U2ADelivering, _impl_.truckid_)
      + sizeof(U2ADelivering::_impl_.truckid_)
      - PROTOBUF_FIELD_OFFSET(U2ADelivering, _impl_.seqnum_)>(
          reinterpret_cast<char*>(&_impl_.seqnum_),
          reinterpret_cast<char*>(&other->_impl_.seqnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata U2ADelivering::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[7]);
}

// ===================================================================

class U2ADelivered::_Internal {
 public:
  using HasBits = decltype(std::declval<U2ADelivered>()._impl_._has_bits_);
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

U2ADelivered::U2ADelivered(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:U2ADelivered)
}
U2ADelivered::U2ADelivered(const U2ADelivered& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shipid_){from._impl_.shipid_}
    , decltype(_impl_.seqnum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.seqnum_ = from._impl_.seqnum_;
  // @@protoc_insertion_point(copy_constructor:U2ADelivered)
}

inline void U2ADelivered::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shipid_){arena}
    , decltype(_impl_.seqnum_){int64_t{0}}
  };
}

U2ADelivered::~U2ADelivered() {
  // @@protoc_insertion_point(destructor:U2ADelivered)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void U2ADelivered::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.shipid_.~RepeatedField();
}

void U2ADelivered::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void U2ADelivered::Clear() {
// @@protoc_insertion_point(message_clear_start:U2ADelivered)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.shipid_.Clear();
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* U2ADelivered::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 seqnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 shipid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_shipid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_shipid(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* U2ADelivered::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:U2ADelivered)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 seqnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seqnum(), target);
  }

  // repeated int64 shipid = 2;
  for (int i = 0, n = this->_internal_shipid_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_shipid(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:U2ADelivered)
  return target;
}

size_t U2ADelivered::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:U2ADelivered)
  size_t total_size = 0;

  // required int64 seqnum = 1;
  if (_internal_has_seqnum()) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 shipid = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.shipid_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_shipid_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData U2ADelivered::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    U2ADelivered::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*U2ADelivered::GetClassData() const { return &_class_data_; }

void U2ADelivered::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<U2ADelivered *>(to)->MergeFrom(
      static_cast<const U2ADelivered &>(from));
}


void U2ADelivered::MergeFrom(const U2ADelivered& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:U2ADelivered)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.shipid_.MergeFrom(from._impl_.shipid_);
  if (from._internal_has_seqnum()) {
    _internal_set_seqnum(from._internal_seqnum());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void U2ADelivered::CopyFrom(const U2ADelivered& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:U2ADelivered)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool U2ADelivered::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void U2ADelivered::InternalSwap(U2ADelivered* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.shipid_.InternalSwap(&other->_impl_.shipid_);
  swap(_impl_.seqnum_, other->_impl_.seqnum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata U2ADelivered::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[8]);
}

// ===================================================================

class PackageInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<PackageInfo>()._impl_._has_bits_);
  static void set_has_shipid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000e) ^ 0x0000000e) != 0;
  }
};

PackageInfo::PackageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PackageInfo)
}
PackageInfo::PackageInfo(const PackageInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.product_){from._impl_.product_}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.shipid_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    _impl_.user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&_impl_.shipid_, &from._impl_.shipid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.shipid_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:PackageInfo)
}

inline void PackageInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.product_){arena}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.shipid_){int64_t{0}}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PackageInfo::~PackageInfo() {
  // @@protoc_insertion_point(destructor:PackageInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PackageInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.product_.~RepeatedPtrField();
  _impl_.user_name_.Destroy();
}

void PackageInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PackageInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PackageInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.product_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.user_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.shipid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.shipid_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PackageInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 shipid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_shipid(&has_bits);
          _impl_.shipid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "PackageInfo.user_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .Product product = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_product(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PackageInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PackageInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 shipid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_shipid(), target);
  }

  // required int32 x = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_x(), target);
  }

  // required int32 y = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_y(), target);
  }

  // optional string user_name = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "PackageInfo.user_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_user_name(), target);
  }

  // repeated .Product product = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_product_size()); i < n; i++) {
    const auto& repfield = this->_internal_product(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PackageInfo)
  return target;
}

size_t PackageInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PackageInfo)
  size_t total_size = 0;

  if (_internal_has_shipid()) {
    // required int64 shipid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());
  }

  if (_internal_has_x()) {
    // required int32 x = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  if (_internal_has_y()) {
    // required int32 y = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  return total_size;
}
size_t PackageInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PackageInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required int64 shipid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());

    // required int32 x = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());

    // required int32 y = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Product product = 5;
  total_size += 1UL * this->_internal_product_size();
  for (const auto& msg : this->_impl_.product_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string user_name = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PackageInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PackageInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PackageInfo::GetClassData() const { return &_class_data_; }

void PackageInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PackageInfo *>(to)->MergeFrom(
      static_cast<const PackageInfo &>(from));
}


void PackageInfo::MergeFrom(const PackageInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PackageInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.product_.MergeFrom(from._impl_.product_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.shipid_ = from._impl_.shipid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.y_ = from._impl_.y_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PackageInfo::CopyFrom(const PackageInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PackageInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PackageInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.product_))
    return false;
  return true;
}

void PackageInfo::InternalSwap(PackageInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.product_.InternalSwap(&other->_impl_.product_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PackageInfo, _impl_.y_)
      + sizeof(PackageInfo::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(PackageInfo, _impl_.shipid_)>(
          reinterpret_cast<char*>(&_impl_.shipid_),
          reinterpret_cast<char*>(&other->_impl_.shipid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PackageInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[9]);
}

// ===================================================================

class Product::_Internal {
 public:
  using HasBits = decltype(std::declval<Product>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

Product::Product(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Product)
}
Product::Product(const Product& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _impl_.name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _impl_.description_.Set(from._internal_description(), 
      GetArenaForAllocation());
  }
  _impl_.count_ = from._impl_.count_;
  // @@protoc_insertion_point(copy_constructor:Product)
}

inline void Product::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.count_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Product::~Product() {
  // @@protoc_insertion_point(destructor:Product)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Product::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
}

void Product::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Product::Clear() {
// @@protoc_insertion_point(message_clear_start:Product)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.count_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Product::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Product.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Product.description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Product::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Product)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Product.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required string description = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Product.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // required int32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Product)
  return target;
}

size_t Product::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Product)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_description()) {
    // required string description = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  if (_internal_has_count()) {
    // required int32 count = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());
  }

  return total_size;
}
size_t Product::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Product)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required string description = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());

    // required int32 count = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Product::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Product::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Product::GetClassData() const { return &_class_data_; }

void Product::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Product *>(to)->MergeFrom(
      static_cast<const Product &>(from));
}


void Product::MergeFrom(const Product& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Product)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.count_ = from._impl_.count_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Product::CopyFrom(const Product& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Product)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Product::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Product::InternalSwap(Product* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  swap(_impl_.count_, other->_impl_.count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Product::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[10]);
}

// ===================================================================

class Warehouse::_Internal {
 public:
  using HasBits = decltype(std::declval<Warehouse>()._impl_._has_bits_);
  static void set_has_warehouseid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

Warehouse::Warehouse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Warehouse)
}
Warehouse::Warehouse(const Warehouse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.warehouseid_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.warehouseid_, &from._impl_.warehouseid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.warehouseid_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:Warehouse)
}

inline void Warehouse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.warehouseid_){0}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

Warehouse::~Warehouse() {
  // @@protoc_insertion_point(destructor:Warehouse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Warehouse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Warehouse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Warehouse::Clear() {
// @@protoc_insertion_point(message_clear_start:Warehouse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.warehouseid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.warehouseid_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Warehouse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 warehouseid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_warehouseid(&has_bits);
          _impl_.warehouseid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Warehouse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Warehouse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 warehouseid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_warehouseid(), target);
  }

  // required int32 x = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_x(), target);
  }

  // required int32 y = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Warehouse)
  return target;
}

size_t Warehouse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Warehouse)
  size_t total_size = 0;

  if (_internal_has_warehouseid()) {
    // required int32 warehouseid = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_warehouseid());
  }

  if (_internal_has_x()) {
    // required int32 x = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  if (_internal_has_y()) {
    // required int32 y = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  return total_size;
}
size_t Warehouse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Warehouse)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int32 warehouseid = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_warehouseid());

    // required int32 x = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());

    // required int32 y = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Warehouse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Warehouse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Warehouse::GetClassData() const { return &_class_data_; }

void Warehouse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Warehouse *>(to)->MergeFrom(
      static_cast<const Warehouse &>(from));
}


void Warehouse::MergeFrom(const Warehouse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Warehouse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.warehouseid_ = from._impl_.warehouseid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.y_ = from._impl_.y_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Warehouse::CopyFrom(const Warehouse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Warehouse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Warehouse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Warehouse::InternalSwap(Warehouse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Warehouse, _impl_.y_)
      + sizeof(Warehouse::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Warehouse, _impl_.warehouseid_)>(
          reinterpret_cast<char*>(&_impl_.warehouseid_),
          reinterpret_cast<char*>(&other->_impl_.warehouseid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Warehouse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[11]);
}

// ===================================================================

class Error::_Internal {
 public:
  using HasBits = decltype(std::declval<Error>()._impl_._has_bits_);
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_originseqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

Error::Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Error)
}
Error::Error(const Error& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.info_){}
    , decltype(_impl_.seqnum_){}
    , decltype(_impl_.originseqnum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_info()) {
    _impl_.info_.Set(from._internal_info(), 
      GetArenaForAllocation());
  }
  ::memcpy(&_impl_.seqnum_, &from._impl_.seqnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.originseqnum_) -
    reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.originseqnum_));
  // @@protoc_insertion_point(copy_constructor:Error)
}

inline void Error::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.info_){}
    , decltype(_impl_.seqnum_){int64_t{0}}
    , decltype(_impl_.originseqnum_){int64_t{0}}
  };
  _impl_.info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Error::~Error() {
  // @@protoc_insertion_point(destructor:Error)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Error::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.info_.Destroy();
}

void Error::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Error::Clear() {
// @@protoc_insertion_point(message_clear_start:Error)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.info_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.seqnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.originseqnum_) -
        reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.originseqnum_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Error::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 seqnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 originseqnum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_originseqnum(&has_bits);
          _impl_.originseqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Error.info");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Error::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Error)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 seqnum = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seqnum(), target);
  }

  // required int64 originseqnum = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_originseqnum(), target);
  }

  // optional string info = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_info().data(), static_cast<int>(this->_internal_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Error.info");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Error)
  return target;
}

size_t Error::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Error)
  size_t total_size = 0;

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  if (_internal_has_originseqnum()) {
    // required int64 originseqnum = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_originseqnum());
  }

  return total_size;
}
size_t Error::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Error)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

    // required int64 originseqnum = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_originseqnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string info = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_info());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Error::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Error::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Error::GetClassData() const { return &_class_data_; }

void Error::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Error *>(to)->MergeFrom(
      static_cast<const Error &>(from));
}


void Error::MergeFrom(const Error& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Error)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_info(from._internal_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.seqnum_ = from._impl_.seqnum_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.originseqnum_ = from._impl_.originseqnum_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Error::CopyFrom(const Error& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Error)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Error::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Error::InternalSwap(Error* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.info_, lhs_arena,
      &other->_impl_.info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Error, _impl_.originseqnum_)
      + sizeof(Error::_impl_.originseqnum_)
      - PROTOBUF_FIELD_OFFSET(Error, _impl_.seqnum_)>(
          reinterpret_cast<char*>(&_impl_.seqnum_),
          reinterpret_cast<char*>(&other->_impl_.seqnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Error::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[12]);
}

// ===================================================================

class A2UQueryShip::_Internal {
 public:
  using HasBits = decltype(std::declval<A2UQueryShip>()._impl_._has_bits_);
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_shipid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

A2UQueryShip::A2UQueryShip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:A2UQueryShip)
}
A2UQueryShip::A2UQueryShip(const A2UQueryShip& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seqnum_){}
    , decltype(_impl_.shipid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.seqnum_, &from._impl_.seqnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shipid_) -
    reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.shipid_));
  // @@protoc_insertion_point(copy_constructor:A2UQueryShip)
}

inline void A2UQueryShip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seqnum_){int64_t{0}}
    , decltype(_impl_.shipid_){int64_t{0}}
  };
}

A2UQueryShip::~A2UQueryShip() {
  // @@protoc_insertion_point(destructor:A2UQueryShip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void A2UQueryShip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void A2UQueryShip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void A2UQueryShip::Clear() {
// @@protoc_insertion_point(message_clear_start:A2UQueryShip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.seqnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shipid_) -
        reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.shipid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* A2UQueryShip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 seqnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 shipid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_shipid(&has_bits);
          _impl_.shipid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* A2UQueryShip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A2UQueryShip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 seqnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seqnum(), target);
  }

  // required int64 shipid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_shipid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A2UQueryShip)
  return target;
}

size_t A2UQueryShip::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:A2UQueryShip)
  size_t total_size = 0;

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  if (_internal_has_shipid()) {
    // required int64 shipid = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());
  }

  return total_size;
}
size_t A2UQueryShip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A2UQueryShip)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

    // required int64 shipid = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData A2UQueryShip::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    A2UQueryShip::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*A2UQueryShip::GetClassData() const { return &_class_data_; }

void A2UQueryShip::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<A2UQueryShip *>(to)->MergeFrom(
      static_cast<const A2UQueryShip &>(from));
}


void A2UQueryShip::MergeFrom(const A2UQueryShip& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:A2UQueryShip)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.seqnum_ = from._impl_.seqnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.shipid_ = from._impl_.shipid_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void A2UQueryShip::CopyFrom(const A2UQueryShip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A2UQueryShip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool A2UQueryShip::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void A2UQueryShip::InternalSwap(A2UQueryShip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(A2UQueryShip, _impl_.shipid_)
      + sizeof(A2UQueryShip::_impl_.shipid_)
      - PROTOBUF_FIELD_OFFSET(A2UQueryShip, _impl_.seqnum_)>(
          reinterpret_cast<char*>(&_impl_.seqnum_),
          reinterpret_cast<char*>(&other->_impl_.seqnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata A2UQueryShip::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[13]);
}

// ===================================================================

class U2AShipStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<U2AShipStatus>()._impl_._has_bits_);
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_shipid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

U2AShipStatus::U2AShipStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:U2AShipStatus)
}
U2AShipStatus::U2AShipStatus(const U2AShipStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seqnum_){}
    , decltype(_impl_.shipid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.seqnum_, &from._impl_.seqnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shipid_) -
    reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.shipid_));
  // @@protoc_insertion_point(copy_constructor:U2AShipStatus)
}

inline void U2AShipStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seqnum_){int64_t{0}}
    , decltype(_impl_.shipid_){int64_t{0}}
  };
}

U2AShipStatus::~U2AShipStatus() {
  // @@protoc_insertion_point(destructor:U2AShipStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void U2AShipStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void U2AShipStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void U2AShipStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:U2AShipStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.seqnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shipid_) -
        reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.shipid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* U2AShipStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 seqnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 shipid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_shipid(&has_bits);
          _impl_.shipid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* U2AShipStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:U2AShipStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 seqnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seqnum(), target);
  }

  // required int64 shipid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_shipid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:U2AShipStatus)
  return target;
}

size_t U2AShipStatus::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:U2AShipStatus)
  size_t total_size = 0;

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  if (_internal_has_shipid()) {
    // required int64 shipid = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());
  }

  return total_size;
}
size_t U2AShipStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:U2AShipStatus)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

    // required int64 shipid = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData U2AShipStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    U2AShipStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*U2AShipStatus::GetClassData() const { return &_class_data_; }

void U2AShipStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<U2AShipStatus *>(to)->MergeFrom(
      static_cast<const U2AShipStatus &>(from));
}


void U2AShipStatus::MergeFrom(const U2AShipStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:U2AShipStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.seqnum_ = from._impl_.seqnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.shipid_ = from._impl_.shipid_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void U2AShipStatus::CopyFrom(const U2AShipStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:U2AShipStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool U2AShipStatus::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void U2AShipStatus::InternalSwap(U2AShipStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(U2AShipStatus, _impl_.shipid_)
      + sizeof(U2AShipStatus::_impl_.shipid_)
      - PROTOBUF_FIELD_OFFSET(U2AShipStatus, _impl_.seqnum_)>(
          reinterpret_cast<char*>(&_impl_.seqnum_),
          reinterpret_cast<char*>(&other->_impl_.seqnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata U2AShipStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[14]);
}

// ===================================================================

class U2AChangeAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<U2AChangeAddress>()._impl_._has_bits_);
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_shipid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

U2AChangeAddress::U2AChangeAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:U2AChangeAddress)
}
U2AChangeAddress::U2AChangeAddress(const U2AChangeAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seqnum_){}
    , decltype(_impl_.shipid_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.seqnum_, &from._impl_.seqnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:U2AChangeAddress)
}

inline void U2AChangeAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seqnum_){int64_t{0}}
    , decltype(_impl_.shipid_){int64_t{0}}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

U2AChangeAddress::~U2AChangeAddress() {
  // @@protoc_insertion_point(destructor:U2AChangeAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void U2AChangeAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void U2AChangeAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void U2AChangeAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:U2AChangeAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.seqnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.seqnum_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* U2AChangeAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 seqnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 shipid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_shipid(&has_bits);
          _impl_.shipid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 x = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 y = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* U2AChangeAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:U2AChangeAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 seqnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seqnum(), target);
  }

  // required int64 shipid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_shipid(), target);
  }

  // required int32 x = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_x(), target);
  }

  // required int32 y = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:U2AChangeAddress)
  return target;
}

size_t U2AChangeAddress::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:U2AChangeAddress)
  size_t total_size = 0;

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  if (_internal_has_shipid()) {
    // required int64 shipid = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());
  }

  if (_internal_has_x()) {
    // required int32 x = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  if (_internal_has_y()) {
    // required int32 y = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  return total_size;
}
size_t U2AChangeAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:U2AChangeAddress)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int64 seqnum = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

    // required int64 shipid = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());

    // required int32 x = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());

    // required int32 y = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData U2AChangeAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    U2AChangeAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*U2AChangeAddress::GetClassData() const { return &_class_data_; }

void U2AChangeAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<U2AChangeAddress *>(to)->MergeFrom(
      static_cast<const U2AChangeAddress &>(from));
}


void U2AChangeAddress::MergeFrom(const U2AChangeAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:U2AChangeAddress)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.seqnum_ = from._impl_.seqnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.shipid_ = from._impl_.shipid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.y_ = from._impl_.y_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void U2AChangeAddress::CopyFrom(const U2AChangeAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:U2AChangeAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool U2AChangeAddress::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void U2AChangeAddress::InternalSwap(U2AChangeAddress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(U2AChangeAddress, _impl_.y_)
      + sizeof(U2AChangeAddress::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(U2AChangeAddress, _impl_.seqnum_)>(
          reinterpret_cast<char*>(&_impl_.seqnum_),
          reinterpret_cast<char*>(&other->_impl_.seqnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata U2AChangeAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[15]);
}

// ===================================================================

class AmazonCommands::_Internal {
 public:
  using HasBits = decltype(std::declval<AmazonCommands>()._impl_._has_bits_);
  static void set_has_finish(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AmazonCommands::AmazonCommands(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:AmazonCommands)
}
AmazonCommands::AmazonCommands(const AmazonCommands& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gettruck_){from._impl_.gettruck_}
    , decltype(_impl_.packed_){from._impl_.packed_}
    , decltype(_impl_.loading_){from._impl_.loading_}
    , decltype(_impl_.loaded_){from._impl_.loaded_}
    , decltype(_impl_.query_){from._impl_.query_}
    , decltype(_impl_.error_){from._impl_.error_}
    , decltype(_impl_.acks_){from._impl_.acks_}
    , decltype(_impl_.finish_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.finish_ = from._impl_.finish_;
  // @@protoc_insertion_point(copy_constructor:AmazonCommands)
}

inline void AmazonCommands::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gettruck_){arena}
    , decltype(_impl_.packed_){arena}
    , decltype(_impl_.loading_){arena}
    , decltype(_impl_.loaded_){arena}
    , decltype(_impl_.query_){arena}
    , decltype(_impl_.error_){arena}
    , decltype(_impl_.acks_){arena}
    , decltype(_impl_.finish_){false}
  };
}

AmazonCommands::~AmazonCommands() {
  // @@protoc_insertion_point(destructor:AmazonCommands)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AmazonCommands::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gettruck_.~RepeatedPtrField();
  _impl_.packed_.~RepeatedPtrField();
  _impl_.loading_.~RepeatedPtrField();
  _impl_.loaded_.~RepeatedPtrField();
  _impl_.query_.~RepeatedPtrField();
  _impl_.error_.~RepeatedPtrField();
  _impl_.acks_.~RepeatedField();
}

void AmazonCommands::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AmazonCommands::Clear() {
// @@protoc_insertion_point(message_clear_start:AmazonCommands)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gettruck_.Clear();
  _impl_.packed_.Clear();
  _impl_.loading_.Clear();
  _impl_.loaded_.Clear();
  _impl_.query_.Clear();
  _impl_.error_.Clear();
  _impl_.acks_.Clear();
  _impl_.finish_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmazonCommands::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .A2UAskTruck getTruck = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gettruck(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .A2UPacked packed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_packed(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .A2ULoading loading = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_loading(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .A2ULoaded loaded = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_loaded(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .A2UQueryShip query = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_query(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Error error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_error(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 acks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_acks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_acks(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool finish = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_finish(&has_bits);
          _impl_.finish_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AmazonCommands::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AmazonCommands)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .A2UAskTruck getTruck = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gettruck_size()); i < n; i++) {
    const auto& repfield = this->_internal_gettruck(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .A2UPacked packed = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_packed_size()); i < n; i++) {
    const auto& repfield = this->_internal_packed(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .A2ULoading loading = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_loading_size()); i < n; i++) {
    const auto& repfield = this->_internal_loading(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .A2ULoaded loaded = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_loaded_size()); i < n; i++) {
    const auto& repfield = this->_internal_loaded(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .A2UQueryShip query = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_query_size()); i < n; i++) {
    const auto& repfield = this->_internal_query(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Error error = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_error_size()); i < n; i++) {
    const auto& repfield = this->_internal_error(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated int64 acks = 7;
  for (int i = 0, n = this->_internal_acks_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_acks(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool finish = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_finish(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AmazonCommands)
  return target;
}

size_t AmazonCommands::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AmazonCommands)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .A2UAskTruck getTruck = 1;
  total_size += 1UL * this->_internal_gettruck_size();
  for (const auto& msg : this->_impl_.gettruck_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .A2UPacked packed = 2;
  total_size += 1UL * this->_internal_packed_size();
  for (const auto& msg : this->_impl_.packed_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .A2ULoading loading = 3;
  total_size += 1UL * this->_internal_loading_size();
  for (const auto& msg : this->_impl_.loading_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .A2ULoaded loaded = 4;
  total_size += 1UL * this->_internal_loaded_size();
  for (const auto& msg : this->_impl_.loaded_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .A2UQueryShip query = 5;
  total_size += 1UL * this->_internal_query_size();
  for (const auto& msg : this->_impl_.query_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Error error = 6;
  total_size += 1UL * this->_internal_error_size();
  for (const auto& msg : this->_impl_.error_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int64 acks = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.acks_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_acks_size());
    total_size += data_size;
  }

  // optional bool finish = 8;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AmazonCommands::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AmazonCommands::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AmazonCommands::GetClassData() const { return &_class_data_; }

void AmazonCommands::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AmazonCommands *>(to)->MergeFrom(
      static_cast<const AmazonCommands &>(from));
}


void AmazonCommands::MergeFrom(const AmazonCommands& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AmazonCommands)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.gettruck_.MergeFrom(from._impl_.gettruck_);
  _impl_.packed_.MergeFrom(from._impl_.packed_);
  _impl_.loading_.MergeFrom(from._impl_.loading_);
  _impl_.loaded_.MergeFrom(from._impl_.loaded_);
  _impl_.query_.MergeFrom(from._impl_.query_);
  _impl_.error_.MergeFrom(from._impl_.error_);
  _impl_.acks_.MergeFrom(from._impl_.acks_);
  if (from._internal_has_finish()) {
    _internal_set_finish(from._internal_finish());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AmazonCommands::CopyFrom(const AmazonCommands& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AmazonCommands)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmazonCommands::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.gettruck_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.packed_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.loading_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.loaded_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.query_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.error_))
    return false;
  return true;
}

void AmazonCommands::InternalSwap(AmazonCommands* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.gettruck_.InternalSwap(&other->_impl_.gettruck_);
  _impl_.packed_.InternalSwap(&other->_impl_.packed_);
  _impl_.loading_.InternalSwap(&other->_impl_.loading_);
  _impl_.loaded_.InternalSwap(&other->_impl_.loaded_);
  _impl_.query_.InternalSwap(&other->_impl_.query_);
  _impl_.error_.InternalSwap(&other->_impl_.error_);
  _impl_.acks_.InternalSwap(&other->_impl_.acks_);
  swap(_impl_.finish_, other->_impl_.finish_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AmazonCommands::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[16]);
}

// ===================================================================

class UPSCommands::_Internal {
 public:
  using HasBits = decltype(std::declval<UPSCommands>()._impl_._has_bits_);
  static void set_has_finish(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UPSCommands::UPSCommands(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UPSCommands)
}
UPSCommands::UPSCommands(const UPSCommands& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.arrived_){from._impl_.arrived_}
    , decltype(_impl_.delivering_){from._impl_.delivering_}
    , decltype(_impl_.delivered_){from._impl_.delivered_}
    , decltype(_impl_.status_){from._impl_.status_}
    , decltype(_impl_.address_){from._impl_.address_}
    , decltype(_impl_.error_){from._impl_.error_}
    , decltype(_impl_.acks_){from._impl_.acks_}
    , decltype(_impl_.finish_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.finish_ = from._impl_.finish_;
  // @@protoc_insertion_point(copy_constructor:UPSCommands)
}

inline void UPSCommands::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.arrived_){arena}
    , decltype(_impl_.delivering_){arena}
    , decltype(_impl_.delivered_){arena}
    , decltype(_impl_.status_){arena}
    , decltype(_impl_.address_){arena}
    , decltype(_impl_.error_){arena}
    , decltype(_impl_.acks_){arena}
    , decltype(_impl_.finish_){false}
  };
}

UPSCommands::~UPSCommands() {
  // @@protoc_insertion_point(destructor:UPSCommands)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UPSCommands::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.arrived_.~RepeatedPtrField();
  _impl_.delivering_.~RepeatedPtrField();
  _impl_.delivered_.~RepeatedPtrField();
  _impl_.status_.~RepeatedPtrField();
  _impl_.address_.~RepeatedPtrField();
  _impl_.error_.~RepeatedPtrField();
  _impl_.acks_.~RepeatedField();
}

void UPSCommands::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UPSCommands::Clear() {
// @@protoc_insertion_point(message_clear_start:UPSCommands)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.arrived_.Clear();
  _impl_.delivering_.Clear();
  _impl_.delivered_.Clear();
  _impl_.status_.Clear();
  _impl_.address_.Clear();
  _impl_.error_.Clear();
  _impl_.acks_.Clear();
  _impl_.finish_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UPSCommands::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .U2ATruckArrived arrived = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_arrived(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .U2ADelivering delivering = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_delivering(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .U2ADelivered delivered = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_delivered(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .U2AShipStatus status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .U2AChangeAddress address = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_address(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Error error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_error(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 acks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_acks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_acks(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool finish = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_finish(&has_bits);
          _impl_.finish_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UPSCommands::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UPSCommands)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .U2ATruckArrived arrived = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_arrived_size()); i < n; i++) {
    const auto& repfield = this->_internal_arrived(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .U2ADelivering delivering = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_delivering_size()); i < n; i++) {
    const auto& repfield = this->_internal_delivering(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .U2ADelivered delivered = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_delivered_size()); i < n; i++) {
    const auto& repfield = this->_internal_delivered(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .U2AShipStatus status = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_status_size()); i < n; i++) {
    const auto& repfield = this->_internal_status(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .U2AChangeAddress address = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_address_size()); i < n; i++) {
    const auto& repfield = this->_internal_address(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Error error = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_error_size()); i < n; i++) {
    const auto& repfield = this->_internal_error(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated int64 acks = 7;
  for (int i = 0, n = this->_internal_acks_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_acks(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool finish = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_finish(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UPSCommands)
  return target;
}

size_t UPSCommands::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UPSCommands)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .U2ATruckArrived arrived = 1;
  total_size += 1UL * this->_internal_arrived_size();
  for (const auto& msg : this->_impl_.arrived_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .U2ADelivering delivering = 2;
  total_size += 1UL * this->_internal_delivering_size();
  for (const auto& msg : this->_impl_.delivering_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .U2ADelivered delivered = 3;
  total_size += 1UL * this->_internal_delivered_size();
  for (const auto& msg : this->_impl_.delivered_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .U2AShipStatus status = 4;
  total_size += 1UL * this->_internal_status_size();
  for (const auto& msg : this->_impl_.status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .U2AChangeAddress address = 5;
  total_size += 1UL * this->_internal_address_size();
  for (const auto& msg : this->_impl_.address_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Error error = 6;
  total_size += 1UL * this->_internal_error_size();
  for (const auto& msg : this->_impl_.error_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int64 acks = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.acks_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_acks_size());
    total_size += data_size;
  }

  // optional bool finish = 8;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UPSCommands::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UPSCommands::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UPSCommands::GetClassData() const { return &_class_data_; }

void UPSCommands::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UPSCommands *>(to)->MergeFrom(
      static_cast<const UPSCommands &>(from));
}


void UPSCommands::MergeFrom(const UPSCommands& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:UPSCommands)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.arrived_.MergeFrom(from._impl_.arrived_);
  _impl_.delivering_.MergeFrom(from._impl_.delivering_);
  _impl_.delivered_.MergeFrom(from._impl_.delivered_);
  _impl_.status_.MergeFrom(from._impl_.status_);
  _impl_.address_.MergeFrom(from._impl_.address_);
  _impl_.error_.MergeFrom(from._impl_.error_);
  _impl_.acks_.MergeFrom(from._impl_.acks_);
  if (from._internal_has_finish()) {
    _internal_set_finish(from._internal_finish());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UPSCommands::CopyFrom(const UPSCommands& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UPSCommands)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UPSCommands::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.arrived_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.delivering_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.delivered_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.status_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.address_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.error_))
    return false;
  return true;
}

void UPSCommands::InternalSwap(UPSCommands* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.arrived_.InternalSwap(&other->_impl_.arrived_);
  _impl_.delivering_.InternalSwap(&other->_impl_.delivering_);
  _impl_.delivered_.InternalSwap(&other->_impl_.delivered_);
  _impl_.status_.InternalSwap(&other->_impl_.status_);
  _impl_.address_.InternalSwap(&other->_impl_.address_);
  _impl_.error_.InternalSwap(&other->_impl_.error_);
  _impl_.acks_.InternalSwap(&other->_impl_.acks_);
  swap(_impl_.finish_, other->_impl_.finish_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UPSCommands::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ups_5famazon_2eproto_getter, &descriptor_table_ups_5famazon_2eproto_once,
      file_level_metadata_ups_5famazon_2eproto[17]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::U2AConnect*
Arena::CreateMaybeMessage< ::U2AConnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::U2AConnect >(arena);
}
template<> PROTOBUF_NOINLINE ::A2UConnected*
Arena::CreateMaybeMessage< ::A2UConnected >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A2UConnected >(arena);
}
template<> PROTOBUF_NOINLINE ::A2UAskTruck*
Arena::CreateMaybeMessage< ::A2UAskTruck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A2UAskTruck >(arena);
}
template<> PROTOBUF_NOINLINE ::A2UPacked*
Arena::CreateMaybeMessage< ::A2UPacked >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A2UPacked >(arena);
}
template<> PROTOBUF_NOINLINE ::A2ULoading*
Arena::CreateMaybeMessage< ::A2ULoading >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A2ULoading >(arena);
}
template<> PROTOBUF_NOINLINE ::A2ULoaded*
Arena::CreateMaybeMessage< ::A2ULoaded >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A2ULoaded >(arena);
}
template<> PROTOBUF_NOINLINE ::U2ATruckArrived*
Arena::CreateMaybeMessage< ::U2ATruckArrived >(Arena* arena) {
  return Arena::CreateMessageInternal< ::U2ATruckArrived >(arena);
}
template<> PROTOBUF_NOINLINE ::U2ADelivering*
Arena::CreateMaybeMessage< ::U2ADelivering >(Arena* arena) {
  return Arena::CreateMessageInternal< ::U2ADelivering >(arena);
}
template<> PROTOBUF_NOINLINE ::U2ADelivered*
Arena::CreateMaybeMessage< ::U2ADelivered >(Arena* arena) {
  return Arena::CreateMessageInternal< ::U2ADelivered >(arena);
}
template<> PROTOBUF_NOINLINE ::PackageInfo*
Arena::CreateMaybeMessage< ::PackageInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PackageInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Product*
Arena::CreateMaybeMessage< ::Product >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Product >(arena);
}
template<> PROTOBUF_NOINLINE ::Warehouse*
Arena::CreateMaybeMessage< ::Warehouse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Warehouse >(arena);
}
template<> PROTOBUF_NOINLINE ::Error*
Arena::CreateMaybeMessage< ::Error >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Error >(arena);
}
template<> PROTOBUF_NOINLINE ::A2UQueryShip*
Arena::CreateMaybeMessage< ::A2UQueryShip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A2UQueryShip >(arena);
}
template<> PROTOBUF_NOINLINE ::U2AShipStatus*
Arena::CreateMaybeMessage< ::U2AShipStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::U2AShipStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::U2AChangeAddress*
Arena::CreateMaybeMessage< ::U2AChangeAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::U2AChangeAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::AmazonCommands*
Arena::CreateMaybeMessage< ::AmazonCommands >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AmazonCommands >(arena);
}
template<> PROTOBUF_NOINLINE ::UPSCommands*
Arena::CreateMaybeMessage< ::UPSCommands >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UPSCommands >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
