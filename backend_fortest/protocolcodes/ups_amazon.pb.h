// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ups_amazon.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ups_5famazon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ups_5famazon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ups_5famazon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ups_5famazon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ups_5famazon_2eproto;
class A2UAskTruck;
struct A2UAskTruckDefaultTypeInternal;
extern A2UAskTruckDefaultTypeInternal _A2UAskTruck_default_instance_;
class A2UConnected;
struct A2UConnectedDefaultTypeInternal;
extern A2UConnectedDefaultTypeInternal _A2UConnected_default_instance_;
class A2ULoaded;
struct A2ULoadedDefaultTypeInternal;
extern A2ULoadedDefaultTypeInternal _A2ULoaded_default_instance_;
class A2ULoading;
struct A2ULoadingDefaultTypeInternal;
extern A2ULoadingDefaultTypeInternal _A2ULoading_default_instance_;
class A2UPacked;
struct A2UPackedDefaultTypeInternal;
extern A2UPackedDefaultTypeInternal _A2UPacked_default_instance_;
class A2UQueryShip;
struct A2UQueryShipDefaultTypeInternal;
extern A2UQueryShipDefaultTypeInternal _A2UQueryShip_default_instance_;
class AmazonCommands;
struct AmazonCommandsDefaultTypeInternal;
extern AmazonCommandsDefaultTypeInternal _AmazonCommands_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class PackageInfo;
struct PackageInfoDefaultTypeInternal;
extern PackageInfoDefaultTypeInternal _PackageInfo_default_instance_;
class Product;
struct ProductDefaultTypeInternal;
extern ProductDefaultTypeInternal _Product_default_instance_;
class U2AChangeAddress;
struct U2AChangeAddressDefaultTypeInternal;
extern U2AChangeAddressDefaultTypeInternal _U2AChangeAddress_default_instance_;
class U2AConnect;
struct U2AConnectDefaultTypeInternal;
extern U2AConnectDefaultTypeInternal _U2AConnect_default_instance_;
class U2ADelivered;
struct U2ADeliveredDefaultTypeInternal;
extern U2ADeliveredDefaultTypeInternal _U2ADelivered_default_instance_;
class U2ADelivering;
struct U2ADeliveringDefaultTypeInternal;
extern U2ADeliveringDefaultTypeInternal _U2ADelivering_default_instance_;
class U2AShipStatus;
struct U2AShipStatusDefaultTypeInternal;
extern U2AShipStatusDefaultTypeInternal _U2AShipStatus_default_instance_;
class U2ATruckArrived;
struct U2ATruckArrivedDefaultTypeInternal;
extern U2ATruckArrivedDefaultTypeInternal _U2ATruckArrived_default_instance_;
class UPSCommands;
struct UPSCommandsDefaultTypeInternal;
extern UPSCommandsDefaultTypeInternal _UPSCommands_default_instance_;
class Warehouse;
struct WarehouseDefaultTypeInternal;
extern WarehouseDefaultTypeInternal _Warehouse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::A2UAskTruck* Arena::CreateMaybeMessage<::A2UAskTruck>(Arena*);
template<> ::A2UConnected* Arena::CreateMaybeMessage<::A2UConnected>(Arena*);
template<> ::A2ULoaded* Arena::CreateMaybeMessage<::A2ULoaded>(Arena*);
template<> ::A2ULoading* Arena::CreateMaybeMessage<::A2ULoading>(Arena*);
template<> ::A2UPacked* Arena::CreateMaybeMessage<::A2UPacked>(Arena*);
template<> ::A2UQueryShip* Arena::CreateMaybeMessage<::A2UQueryShip>(Arena*);
template<> ::AmazonCommands* Arena::CreateMaybeMessage<::AmazonCommands>(Arena*);
template<> ::Error* Arena::CreateMaybeMessage<::Error>(Arena*);
template<> ::PackageInfo* Arena::CreateMaybeMessage<::PackageInfo>(Arena*);
template<> ::Product* Arena::CreateMaybeMessage<::Product>(Arena*);
template<> ::U2AChangeAddress* Arena::CreateMaybeMessage<::U2AChangeAddress>(Arena*);
template<> ::U2AConnect* Arena::CreateMaybeMessage<::U2AConnect>(Arena*);
template<> ::U2ADelivered* Arena::CreateMaybeMessage<::U2ADelivered>(Arena*);
template<> ::U2ADelivering* Arena::CreateMaybeMessage<::U2ADelivering>(Arena*);
template<> ::U2AShipStatus* Arena::CreateMaybeMessage<::U2AShipStatus>(Arena*);
template<> ::U2ATruckArrived* Arena::CreateMaybeMessage<::U2ATruckArrived>(Arena*);
template<> ::UPSCommands* Arena::CreateMaybeMessage<::UPSCommands>(Arena*);
template<> ::Warehouse* Arena::CreateMaybeMessage<::Warehouse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class U2AConnect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:U2AConnect) */ {
 public:
  inline U2AConnect() : U2AConnect(nullptr) {}
  ~U2AConnect() override;
  explicit PROTOBUF_CONSTEXPR U2AConnect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  U2AConnect(const U2AConnect& from);
  U2AConnect(U2AConnect&& from) noexcept
    : U2AConnect() {
    *this = ::std::move(from);
  }

  inline U2AConnect& operator=(const U2AConnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline U2AConnect& operator=(U2AConnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const U2AConnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const U2AConnect* internal_default_instance() {
    return reinterpret_cast<const U2AConnect*>(
               &_U2AConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(U2AConnect& a, U2AConnect& b) {
    a.Swap(&b);
  }
  inline void Swap(U2AConnect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(U2AConnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  U2AConnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<U2AConnect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const U2AConnect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const U2AConnect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(U2AConnect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "U2AConnect";
  }
  protected:
  explicit U2AConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldidFieldNumber = 1,
  };
  // required int64 worldid = 1;
  bool has_worldid() const;
  private:
  bool _internal_has_worldid() const;
  public:
  void clear_worldid();
  int64_t worldid() const;
  void set_worldid(int64_t value);
  private:
  int64_t _internal_worldid() const;
  void _internal_set_worldid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:U2AConnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t worldid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class A2UConnected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A2UConnected) */ {
 public:
  inline A2UConnected() : A2UConnected(nullptr) {}
  ~A2UConnected() override;
  explicit PROTOBUF_CONSTEXPR A2UConnected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  A2UConnected(const A2UConnected& from);
  A2UConnected(A2UConnected&& from) noexcept
    : A2UConnected() {
    *this = ::std::move(from);
  }

  inline A2UConnected& operator=(const A2UConnected& from) {
    CopyFrom(from);
    return *this;
  }
  inline A2UConnected& operator=(A2UConnected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const A2UConnected& default_instance() {
    return *internal_default_instance();
  }
  static inline const A2UConnected* internal_default_instance() {
    return reinterpret_cast<const A2UConnected*>(
               &_A2UConnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(A2UConnected& a, A2UConnected& b) {
    a.Swap(&b);
  }
  inline void Swap(A2UConnected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(A2UConnected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  A2UConnected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<A2UConnected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const A2UConnected& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const A2UConnected& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(A2UConnected* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "A2UConnected";
  }
  protected:
  explicit A2UConnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kWorldidFieldNumber = 1,
  };
  // required string result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // required int64 worldid = 1;
  bool has_worldid() const;
  private:
  bool _internal_has_worldid() const;
  public:
  void clear_worldid();
  int64_t worldid() const;
  void set_worldid(int64_t value);
  private:
  int64_t _internal_worldid() const;
  void _internal_set_worldid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:A2UConnected)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    int64_t worldid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class A2UAskTruck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A2UAskTruck) */ {
 public:
  inline A2UAskTruck() : A2UAskTruck(nullptr) {}
  ~A2UAskTruck() override;
  explicit PROTOBUF_CONSTEXPR A2UAskTruck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  A2UAskTruck(const A2UAskTruck& from);
  A2UAskTruck(A2UAskTruck&& from) noexcept
    : A2UAskTruck() {
    *this = ::std::move(from);
  }

  inline A2UAskTruck& operator=(const A2UAskTruck& from) {
    CopyFrom(from);
    return *this;
  }
  inline A2UAskTruck& operator=(A2UAskTruck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const A2UAskTruck& default_instance() {
    return *internal_default_instance();
  }
  static inline const A2UAskTruck* internal_default_instance() {
    return reinterpret_cast<const A2UAskTruck*>(
               &_A2UAskTruck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(A2UAskTruck& a, A2UAskTruck& b) {
    a.Swap(&b);
  }
  inline void Swap(A2UAskTruck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(A2UAskTruck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  A2UAskTruck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<A2UAskTruck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const A2UAskTruck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const A2UAskTruck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(A2UAskTruck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "A2UAskTruck";
  }
  protected:
  explicit A2UAskTruck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageFieldNumber = 3,
    kWarehouseFieldNumber = 2,
    kSeqnumFieldNumber = 1,
  };
  // repeated .PackageInfo package = 3;
  int package_size() const;
  private:
  int _internal_package_size() const;
  public:
  void clear_package();
  ::PackageInfo* mutable_package(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PackageInfo >*
      mutable_package();
  private:
  const ::PackageInfo& _internal_package(int index) const;
  ::PackageInfo* _internal_add_package();
  public:
  const ::PackageInfo& package(int index) const;
  ::PackageInfo* add_package();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PackageInfo >&
      package() const;

  // required .Warehouse warehouse = 2;
  bool has_warehouse() const;
  private:
  bool _internal_has_warehouse() const;
  public:
  void clear_warehouse();
  const ::Warehouse& warehouse() const;
  PROTOBUF_NODISCARD ::Warehouse* release_warehouse();
  ::Warehouse* mutable_warehouse();
  void set_allocated_warehouse(::Warehouse* warehouse);
  private:
  const ::Warehouse& _internal_warehouse() const;
  ::Warehouse* _internal_mutable_warehouse();
  public:
  void unsafe_arena_set_allocated_warehouse(
      ::Warehouse* warehouse);
  ::Warehouse* unsafe_arena_release_warehouse();

  // required int64 seqnum = 1;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:A2UAskTruck)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PackageInfo > package_;
    ::Warehouse* warehouse_;
    int64_t seqnum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class A2UPacked final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A2UPacked) */ {
 public:
  inline A2UPacked() : A2UPacked(nullptr) {}
  ~A2UPacked() override;
  explicit PROTOBUF_CONSTEXPR A2UPacked(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  A2UPacked(const A2UPacked& from);
  A2UPacked(A2UPacked&& from) noexcept
    : A2UPacked() {
    *this = ::std::move(from);
  }

  inline A2UPacked& operator=(const A2UPacked& from) {
    CopyFrom(from);
    return *this;
  }
  inline A2UPacked& operator=(A2UPacked&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const A2UPacked& default_instance() {
    return *internal_default_instance();
  }
  static inline const A2UPacked* internal_default_instance() {
    return reinterpret_cast<const A2UPacked*>(
               &_A2UPacked_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(A2UPacked& a, A2UPacked& b) {
    a.Swap(&b);
  }
  inline void Swap(A2UPacked* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(A2UPacked* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  A2UPacked* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<A2UPacked>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const A2UPacked& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const A2UPacked& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(A2UPacked* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "A2UPacked";
  }
  protected:
  explicit A2UPacked(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqnumFieldNumber = 1,
    kShipidFieldNumber = 2,
  };
  // required int64 seqnum = 1;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // required int64 shipid = 2;
  bool has_shipid() const;
  private:
  bool _internal_has_shipid() const;
  public:
  void clear_shipid();
  int64_t shipid() const;
  void set_shipid(int64_t value);
  private:
  int64_t _internal_shipid() const;
  void _internal_set_shipid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:A2UPacked)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t seqnum_;
    int64_t shipid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class A2ULoading final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A2ULoading) */ {
 public:
  inline A2ULoading() : A2ULoading(nullptr) {}
  ~A2ULoading() override;
  explicit PROTOBUF_CONSTEXPR A2ULoading(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  A2ULoading(const A2ULoading& from);
  A2ULoading(A2ULoading&& from) noexcept
    : A2ULoading() {
    *this = ::std::move(from);
  }

  inline A2ULoading& operator=(const A2ULoading& from) {
    CopyFrom(from);
    return *this;
  }
  inline A2ULoading& operator=(A2ULoading&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const A2ULoading& default_instance() {
    return *internal_default_instance();
  }
  static inline const A2ULoading* internal_default_instance() {
    return reinterpret_cast<const A2ULoading*>(
               &_A2ULoading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(A2ULoading& a, A2ULoading& b) {
    a.Swap(&b);
  }
  inline void Swap(A2ULoading* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(A2ULoading* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  A2ULoading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<A2ULoading>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const A2ULoading& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const A2ULoading& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(A2ULoading* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "A2ULoading";
  }
  protected:
  explicit A2ULoading(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShipidFieldNumber = 4,
    kWarehouseFieldNumber = 2,
    kSeqnumFieldNumber = 1,
    kTruckidFieldNumber = 3,
  };
  // repeated int64 shipid = 4;
  int shipid_size() const;
  private:
  int _internal_shipid_size() const;
  public:
  void clear_shipid();
  private:
  int64_t _internal_shipid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shipid() const;
  void _internal_add_shipid(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shipid();
  public:
  int64_t shipid(int index) const;
  void set_shipid(int index, int64_t value);
  void add_shipid(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shipid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shipid();

  // required .Warehouse warehouse = 2;
  bool has_warehouse() const;
  private:
  bool _internal_has_warehouse() const;
  public:
  void clear_warehouse();
  const ::Warehouse& warehouse() const;
  PROTOBUF_NODISCARD ::Warehouse* release_warehouse();
  ::Warehouse* mutable_warehouse();
  void set_allocated_warehouse(::Warehouse* warehouse);
  private:
  const ::Warehouse& _internal_warehouse() const;
  ::Warehouse* _internal_mutable_warehouse();
  public:
  void unsafe_arena_set_allocated_warehouse(
      ::Warehouse* warehouse);
  ::Warehouse* unsafe_arena_release_warehouse();

  // required int64 seqnum = 1;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // required int32 truckid = 3;
  bool has_truckid() const;
  private:
  bool _internal_has_truckid() const;
  public:
  void clear_truckid();
  int32_t truckid() const;
  void set_truckid(int32_t value);
  private:
  int32_t _internal_truckid() const;
  void _internal_set_truckid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:A2ULoading)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shipid_;
    ::Warehouse* warehouse_;
    int64_t seqnum_;
    int32_t truckid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class A2ULoaded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A2ULoaded) */ {
 public:
  inline A2ULoaded() : A2ULoaded(nullptr) {}
  ~A2ULoaded() override;
  explicit PROTOBUF_CONSTEXPR A2ULoaded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  A2ULoaded(const A2ULoaded& from);
  A2ULoaded(A2ULoaded&& from) noexcept
    : A2ULoaded() {
    *this = ::std::move(from);
  }

  inline A2ULoaded& operator=(const A2ULoaded& from) {
    CopyFrom(from);
    return *this;
  }
  inline A2ULoaded& operator=(A2ULoaded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const A2ULoaded& default_instance() {
    return *internal_default_instance();
  }
  static inline const A2ULoaded* internal_default_instance() {
    return reinterpret_cast<const A2ULoaded*>(
               &_A2ULoaded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(A2ULoaded& a, A2ULoaded& b) {
    a.Swap(&b);
  }
  inline void Swap(A2ULoaded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(A2ULoaded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  A2ULoaded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<A2ULoaded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const A2ULoaded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const A2ULoaded& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(A2ULoaded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "A2ULoaded";
  }
  protected:
  explicit A2ULoaded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShipidFieldNumber = 4,
    kWarehouseFieldNumber = 2,
    kSeqnumFieldNumber = 1,
    kTruckidFieldNumber = 3,
  };
  // repeated int64 shipid = 4;
  int shipid_size() const;
  private:
  int _internal_shipid_size() const;
  public:
  void clear_shipid();
  private:
  int64_t _internal_shipid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shipid() const;
  void _internal_add_shipid(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shipid();
  public:
  int64_t shipid(int index) const;
  void set_shipid(int index, int64_t value);
  void add_shipid(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shipid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shipid();

  // required .Warehouse warehouse = 2;
  bool has_warehouse() const;
  private:
  bool _internal_has_warehouse() const;
  public:
  void clear_warehouse();
  const ::Warehouse& warehouse() const;
  PROTOBUF_NODISCARD ::Warehouse* release_warehouse();
  ::Warehouse* mutable_warehouse();
  void set_allocated_warehouse(::Warehouse* warehouse);
  private:
  const ::Warehouse& _internal_warehouse() const;
  ::Warehouse* _internal_mutable_warehouse();
  public:
  void unsafe_arena_set_allocated_warehouse(
      ::Warehouse* warehouse);
  ::Warehouse* unsafe_arena_release_warehouse();

  // required int64 seqnum = 1;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // required int32 truckid = 3;
  bool has_truckid() const;
  private:
  bool _internal_has_truckid() const;
  public:
  void clear_truckid();
  int32_t truckid() const;
  void set_truckid(int32_t value);
  private:
  int32_t _internal_truckid() const;
  void _internal_set_truckid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:A2ULoaded)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shipid_;
    ::Warehouse* warehouse_;
    int64_t seqnum_;
    int32_t truckid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class U2ATruckArrived final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:U2ATruckArrived) */ {
 public:
  inline U2ATruckArrived() : U2ATruckArrived(nullptr) {}
  ~U2ATruckArrived() override;
  explicit PROTOBUF_CONSTEXPR U2ATruckArrived(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  U2ATruckArrived(const U2ATruckArrived& from);
  U2ATruckArrived(U2ATruckArrived&& from) noexcept
    : U2ATruckArrived() {
    *this = ::std::move(from);
  }

  inline U2ATruckArrived& operator=(const U2ATruckArrived& from) {
    CopyFrom(from);
    return *this;
  }
  inline U2ATruckArrived& operator=(U2ATruckArrived&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const U2ATruckArrived& default_instance() {
    return *internal_default_instance();
  }
  static inline const U2ATruckArrived* internal_default_instance() {
    return reinterpret_cast<const U2ATruckArrived*>(
               &_U2ATruckArrived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(U2ATruckArrived& a, U2ATruckArrived& b) {
    a.Swap(&b);
  }
  inline void Swap(U2ATruckArrived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(U2ATruckArrived* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  U2ATruckArrived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<U2ATruckArrived>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const U2ATruckArrived& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const U2ATruckArrived& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(U2ATruckArrived* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "U2ATruckArrived";
  }
  protected:
  explicit U2ATruckArrived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShipidFieldNumber = 4,
    kWarehouseFieldNumber = 2,
    kSeqnumFieldNumber = 1,
    kTruckidFieldNumber = 3,
  };
  // repeated int64 shipid = 4;
  int shipid_size() const;
  private:
  int _internal_shipid_size() const;
  public:
  void clear_shipid();
  private:
  int64_t _internal_shipid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shipid() const;
  void _internal_add_shipid(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shipid();
  public:
  int64_t shipid(int index) const;
  void set_shipid(int index, int64_t value);
  void add_shipid(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shipid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shipid();

  // required .Warehouse warehouse = 2;
  bool has_warehouse() const;
  private:
  bool _internal_has_warehouse() const;
  public:
  void clear_warehouse();
  const ::Warehouse& warehouse() const;
  PROTOBUF_NODISCARD ::Warehouse* release_warehouse();
  ::Warehouse* mutable_warehouse();
  void set_allocated_warehouse(::Warehouse* warehouse);
  private:
  const ::Warehouse& _internal_warehouse() const;
  ::Warehouse* _internal_mutable_warehouse();
  public:
  void unsafe_arena_set_allocated_warehouse(
      ::Warehouse* warehouse);
  ::Warehouse* unsafe_arena_release_warehouse();

  // required int64 seqnum = 1;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // required int32 truckid = 3;
  bool has_truckid() const;
  private:
  bool _internal_has_truckid() const;
  public:
  void clear_truckid();
  int32_t truckid() const;
  void set_truckid(int32_t value);
  private:
  int32_t _internal_truckid() const;
  void _internal_set_truckid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:U2ATruckArrived)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shipid_;
    ::Warehouse* warehouse_;
    int64_t seqnum_;
    int32_t truckid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class U2ADelivering final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:U2ADelivering) */ {
 public:
  inline U2ADelivering() : U2ADelivering(nullptr) {}
  ~U2ADelivering() override;
  explicit PROTOBUF_CONSTEXPR U2ADelivering(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  U2ADelivering(const U2ADelivering& from);
  U2ADelivering(U2ADelivering&& from) noexcept
    : U2ADelivering() {
    *this = ::std::move(from);
  }

  inline U2ADelivering& operator=(const U2ADelivering& from) {
    CopyFrom(from);
    return *this;
  }
  inline U2ADelivering& operator=(U2ADelivering&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const U2ADelivering& default_instance() {
    return *internal_default_instance();
  }
  static inline const U2ADelivering* internal_default_instance() {
    return reinterpret_cast<const U2ADelivering*>(
               &_U2ADelivering_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(U2ADelivering& a, U2ADelivering& b) {
    a.Swap(&b);
  }
  inline void Swap(U2ADelivering* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(U2ADelivering* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  U2ADelivering* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<U2ADelivering>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const U2ADelivering& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const U2ADelivering& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(U2ADelivering* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "U2ADelivering";
  }
  protected:
  explicit U2ADelivering(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShipidFieldNumber = 2,
    kSeqnumFieldNumber = 1,
    kTruckidFieldNumber = 3,
  };
  // repeated int64 shipid = 2;
  int shipid_size() const;
  private:
  int _internal_shipid_size() const;
  public:
  void clear_shipid();
  private:
  int64_t _internal_shipid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shipid() const;
  void _internal_add_shipid(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shipid();
  public:
  int64_t shipid(int index) const;
  void set_shipid(int index, int64_t value);
  void add_shipid(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shipid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shipid();

  // required int64 seqnum = 1;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // required int32 truckid = 3;
  bool has_truckid() const;
  private:
  bool _internal_has_truckid() const;
  public:
  void clear_truckid();
  int32_t truckid() const;
  void set_truckid(int32_t value);
  private:
  int32_t _internal_truckid() const;
  void _internal_set_truckid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:U2ADelivering)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shipid_;
    int64_t seqnum_;
    int32_t truckid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class U2ADelivered final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:U2ADelivered) */ {
 public:
  inline U2ADelivered() : U2ADelivered(nullptr) {}
  ~U2ADelivered() override;
  explicit PROTOBUF_CONSTEXPR U2ADelivered(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  U2ADelivered(const U2ADelivered& from);
  U2ADelivered(U2ADelivered&& from) noexcept
    : U2ADelivered() {
    *this = ::std::move(from);
  }

  inline U2ADelivered& operator=(const U2ADelivered& from) {
    CopyFrom(from);
    return *this;
  }
  inline U2ADelivered& operator=(U2ADelivered&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const U2ADelivered& default_instance() {
    return *internal_default_instance();
  }
  static inline const U2ADelivered* internal_default_instance() {
    return reinterpret_cast<const U2ADelivered*>(
               &_U2ADelivered_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(U2ADelivered& a, U2ADelivered& b) {
    a.Swap(&b);
  }
  inline void Swap(U2ADelivered* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(U2ADelivered* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  U2ADelivered* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<U2ADelivered>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const U2ADelivered& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const U2ADelivered& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(U2ADelivered* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "U2ADelivered";
  }
  protected:
  explicit U2ADelivered(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShipidFieldNumber = 2,
    kSeqnumFieldNumber = 1,
  };
  // repeated int64 shipid = 2;
  int shipid_size() const;
  private:
  int _internal_shipid_size() const;
  public:
  void clear_shipid();
  private:
  int64_t _internal_shipid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_shipid() const;
  void _internal_add_shipid(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_shipid();
  public:
  int64_t shipid(int index) const;
  void set_shipid(int index, int64_t value);
  void add_shipid(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      shipid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_shipid();

  // required int64 seqnum = 1;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:U2ADelivered)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > shipid_;
    int64_t seqnum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class PackageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PackageInfo) */ {
 public:
  inline PackageInfo() : PackageInfo(nullptr) {}
  ~PackageInfo() override;
  explicit PROTOBUF_CONSTEXPR PackageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PackageInfo(const PackageInfo& from);
  PackageInfo(PackageInfo&& from) noexcept
    : PackageInfo() {
    *this = ::std::move(from);
  }

  inline PackageInfo& operator=(const PackageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PackageInfo& operator=(PackageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PackageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PackageInfo* internal_default_instance() {
    return reinterpret_cast<const PackageInfo*>(
               &_PackageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PackageInfo& a, PackageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PackageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PackageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PackageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PackageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PackageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PackageInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PackageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PackageInfo";
  }
  protected:
  explicit PackageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductFieldNumber = 5,
    kUserNameFieldNumber = 4,
    kShipidFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // repeated .Product product = 5;
  int product_size() const;
  private:
  int _internal_product_size() const;
  public:
  void clear_product();
  ::Product* mutable_product(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Product >*
      mutable_product();
  private:
  const ::Product& _internal_product(int index) const;
  ::Product* _internal_add_product();
  public:
  const ::Product& product(int index) const;
  ::Product* add_product();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Product >&
      product() const;

  // optional string user_name = 4;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // required int64 shipid = 1;
  bool has_shipid() const;
  private:
  bool _internal_has_shipid() const;
  public:
  void clear_shipid();
  int64_t shipid() const;
  void set_shipid(int64_t value);
  private:
  int64_t _internal_shipid() const;
  void _internal_set_shipid(int64_t value);
  public:

  // required int32 x = 2;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // required int32 y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PackageInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Product > product_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    int64_t shipid_;
    int32_t x_;
    int32_t y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class Product final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Product) */ {
 public:
  inline Product() : Product(nullptr) {}
  ~Product() override;
  explicit PROTOBUF_CONSTEXPR Product(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Product(const Product& from);
  Product(Product&& from) noexcept
    : Product() {
    *this = ::std::move(from);
  }

  inline Product& operator=(const Product& from) {
    CopyFrom(from);
    return *this;
  }
  inline Product& operator=(Product&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Product& default_instance() {
    return *internal_default_instance();
  }
  static inline const Product* internal_default_instance() {
    return reinterpret_cast<const Product*>(
               &_Product_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Product& a, Product& b) {
    a.Swap(&b);
  }
  inline void Swap(Product* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Product* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Product* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Product>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Product& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Product& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Product* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Product";
  }
  protected:
  explicit Product(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string description = 2;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // required int32 count = 3;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Product)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int32_t count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class Warehouse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Warehouse) */ {
 public:
  inline Warehouse() : Warehouse(nullptr) {}
  ~Warehouse() override;
  explicit PROTOBUF_CONSTEXPR Warehouse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Warehouse(const Warehouse& from);
  Warehouse(Warehouse&& from) noexcept
    : Warehouse() {
    *this = ::std::move(from);
  }

  inline Warehouse& operator=(const Warehouse& from) {
    CopyFrom(from);
    return *this;
  }
  inline Warehouse& operator=(Warehouse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Warehouse& default_instance() {
    return *internal_default_instance();
  }
  static inline const Warehouse* internal_default_instance() {
    return reinterpret_cast<const Warehouse*>(
               &_Warehouse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Warehouse& a, Warehouse& b) {
    a.Swap(&b);
  }
  inline void Swap(Warehouse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Warehouse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Warehouse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Warehouse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Warehouse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Warehouse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Warehouse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Warehouse";
  }
  protected:
  explicit Warehouse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWarehouseidFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // required int32 warehouseid = 1;
  bool has_warehouseid() const;
  private:
  bool _internal_has_warehouseid() const;
  public:
  void clear_warehouseid();
  int32_t warehouseid() const;
  void set_warehouseid(int32_t value);
  private:
  int32_t _internal_warehouseid() const;
  void _internal_set_warehouseid(int32_t value);
  public:

  // required int32 x = 2;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // required int32 y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Warehouse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t warehouseid_;
    int32_t x_;
    int32_t y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit PROTOBUF_CONSTEXPR Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Error& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 3,
    kSeqnumFieldNumber = 1,
    kOriginseqnumFieldNumber = 2,
  };
  // optional string info = 3;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // required int64 seqnum = 1;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // required int64 originseqnum = 2;
  bool has_originseqnum() const;
  private:
  bool _internal_has_originseqnum() const;
  public:
  void clear_originseqnum();
  int64_t originseqnum() const;
  void set_originseqnum(int64_t value);
  private:
  int64_t _internal_originseqnum() const;
  void _internal_set_originseqnum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Error)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
    int64_t seqnum_;
    int64_t originseqnum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class A2UQueryShip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A2UQueryShip) */ {
 public:
  inline A2UQueryShip() : A2UQueryShip(nullptr) {}
  ~A2UQueryShip() override;
  explicit PROTOBUF_CONSTEXPR A2UQueryShip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  A2UQueryShip(const A2UQueryShip& from);
  A2UQueryShip(A2UQueryShip&& from) noexcept
    : A2UQueryShip() {
    *this = ::std::move(from);
  }

  inline A2UQueryShip& operator=(const A2UQueryShip& from) {
    CopyFrom(from);
    return *this;
  }
  inline A2UQueryShip& operator=(A2UQueryShip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const A2UQueryShip& default_instance() {
    return *internal_default_instance();
  }
  static inline const A2UQueryShip* internal_default_instance() {
    return reinterpret_cast<const A2UQueryShip*>(
               &_A2UQueryShip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(A2UQueryShip& a, A2UQueryShip& b) {
    a.Swap(&b);
  }
  inline void Swap(A2UQueryShip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(A2UQueryShip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  A2UQueryShip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<A2UQueryShip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const A2UQueryShip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const A2UQueryShip& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(A2UQueryShip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "A2UQueryShip";
  }
  protected:
  explicit A2UQueryShip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqnumFieldNumber = 1,
    kShipidFieldNumber = 2,
  };
  // required int64 seqnum = 1;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // required int64 shipid = 2;
  bool has_shipid() const;
  private:
  bool _internal_has_shipid() const;
  public:
  void clear_shipid();
  int64_t shipid() const;
  void set_shipid(int64_t value);
  private:
  int64_t _internal_shipid() const;
  void _internal_set_shipid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:A2UQueryShip)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t seqnum_;
    int64_t shipid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class U2AShipStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:U2AShipStatus) */ {
 public:
  inline U2AShipStatus() : U2AShipStatus(nullptr) {}
  ~U2AShipStatus() override;
  explicit PROTOBUF_CONSTEXPR U2AShipStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  U2AShipStatus(const U2AShipStatus& from);
  U2AShipStatus(U2AShipStatus&& from) noexcept
    : U2AShipStatus() {
    *this = ::std::move(from);
  }

  inline U2AShipStatus& operator=(const U2AShipStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline U2AShipStatus& operator=(U2AShipStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const U2AShipStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const U2AShipStatus* internal_default_instance() {
    return reinterpret_cast<const U2AShipStatus*>(
               &_U2AShipStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(U2AShipStatus& a, U2AShipStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(U2AShipStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(U2AShipStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  U2AShipStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<U2AShipStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const U2AShipStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const U2AShipStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(U2AShipStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "U2AShipStatus";
  }
  protected:
  explicit U2AShipStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 3,
    kSeqnumFieldNumber = 1,
    kShipidFieldNumber = 2,
  };
  // required string status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // required int64 seqnum = 1;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // required int64 shipid = 2;
  bool has_shipid() const;
  private:
  bool _internal_has_shipid() const;
  public:
  void clear_shipid();
  int64_t shipid() const;
  void set_shipid(int64_t value);
  private:
  int64_t _internal_shipid() const;
  void _internal_set_shipid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:U2AShipStatus)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    int64_t seqnum_;
    int64_t shipid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class U2AChangeAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:U2AChangeAddress) */ {
 public:
  inline U2AChangeAddress() : U2AChangeAddress(nullptr) {}
  ~U2AChangeAddress() override;
  explicit PROTOBUF_CONSTEXPR U2AChangeAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  U2AChangeAddress(const U2AChangeAddress& from);
  U2AChangeAddress(U2AChangeAddress&& from) noexcept
    : U2AChangeAddress() {
    *this = ::std::move(from);
  }

  inline U2AChangeAddress& operator=(const U2AChangeAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline U2AChangeAddress& operator=(U2AChangeAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const U2AChangeAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const U2AChangeAddress* internal_default_instance() {
    return reinterpret_cast<const U2AChangeAddress*>(
               &_U2AChangeAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(U2AChangeAddress& a, U2AChangeAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(U2AChangeAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(U2AChangeAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  U2AChangeAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<U2AChangeAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const U2AChangeAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const U2AChangeAddress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(U2AChangeAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "U2AChangeAddress";
  }
  protected:
  explicit U2AChangeAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqnumFieldNumber = 1,
    kShipidFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
  };
  // required int64 seqnum = 1;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // required int64 shipid = 2;
  bool has_shipid() const;
  private:
  bool _internal_has_shipid() const;
  public:
  void clear_shipid();
  int64_t shipid() const;
  void set_shipid(int64_t value);
  private:
  int64_t _internal_shipid() const;
  void _internal_set_shipid(int64_t value);
  public:

  // required int32 x = 3;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // required int32 y = 4;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:U2AChangeAddress)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t seqnum_;
    int64_t shipid_;
    int32_t x_;
    int32_t y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class AmazonCommands final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmazonCommands) */ {
 public:
  inline AmazonCommands() : AmazonCommands(nullptr) {}
  ~AmazonCommands() override;
  explicit PROTOBUF_CONSTEXPR AmazonCommands(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AmazonCommands(const AmazonCommands& from);
  AmazonCommands(AmazonCommands&& from) noexcept
    : AmazonCommands() {
    *this = ::std::move(from);
  }

  inline AmazonCommands& operator=(const AmazonCommands& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmazonCommands& operator=(AmazonCommands&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AmazonCommands& default_instance() {
    return *internal_default_instance();
  }
  static inline const AmazonCommands* internal_default_instance() {
    return reinterpret_cast<const AmazonCommands*>(
               &_AmazonCommands_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AmazonCommands& a, AmazonCommands& b) {
    a.Swap(&b);
  }
  inline void Swap(AmazonCommands* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmazonCommands* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AmazonCommands* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AmazonCommands>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AmazonCommands& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AmazonCommands& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmazonCommands* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmazonCommands";
  }
  protected:
  explicit AmazonCommands(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGetTruckFieldNumber = 1,
    kPackedFieldNumber = 2,
    kLoadingFieldNumber = 3,
    kLoadedFieldNumber = 4,
    kQueryFieldNumber = 5,
    kErrorFieldNumber = 6,
    kAcksFieldNumber = 7,
    kFinishFieldNumber = 8,
  };
  // repeated .A2UAskTruck getTruck = 1;
  int gettruck_size() const;
  private:
  int _internal_gettruck_size() const;
  public:
  void clear_gettruck();
  ::A2UAskTruck* mutable_gettruck(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UAskTruck >*
      mutable_gettruck();
  private:
  const ::A2UAskTruck& _internal_gettruck(int index) const;
  ::A2UAskTruck* _internal_add_gettruck();
  public:
  const ::A2UAskTruck& gettruck(int index) const;
  ::A2UAskTruck* add_gettruck();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UAskTruck >&
      gettruck() const;

  // repeated .A2UPacked packed = 2;
  int packed_size() const;
  private:
  int _internal_packed_size() const;
  public:
  void clear_packed();
  ::A2UPacked* mutable_packed(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UPacked >*
      mutable_packed();
  private:
  const ::A2UPacked& _internal_packed(int index) const;
  ::A2UPacked* _internal_add_packed();
  public:
  const ::A2UPacked& packed(int index) const;
  ::A2UPacked* add_packed();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UPacked >&
      packed() const;

  // repeated .A2ULoading loading = 3;
  int loading_size() const;
  private:
  int _internal_loading_size() const;
  public:
  void clear_loading();
  ::A2ULoading* mutable_loading(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2ULoading >*
      mutable_loading();
  private:
  const ::A2ULoading& _internal_loading(int index) const;
  ::A2ULoading* _internal_add_loading();
  public:
  const ::A2ULoading& loading(int index) const;
  ::A2ULoading* add_loading();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2ULoading >&
      loading() const;

  // repeated .A2ULoaded loaded = 4;
  int loaded_size() const;
  private:
  int _internal_loaded_size() const;
  public:
  void clear_loaded();
  ::A2ULoaded* mutable_loaded(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2ULoaded >*
      mutable_loaded();
  private:
  const ::A2ULoaded& _internal_loaded(int index) const;
  ::A2ULoaded* _internal_add_loaded();
  public:
  const ::A2ULoaded& loaded(int index) const;
  ::A2ULoaded* add_loaded();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2ULoaded >&
      loaded() const;

  // repeated .A2UQueryShip query = 5;
  int query_size() const;
  private:
  int _internal_query_size() const;
  public:
  void clear_query();
  ::A2UQueryShip* mutable_query(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UQueryShip >*
      mutable_query();
  private:
  const ::A2UQueryShip& _internal_query(int index) const;
  ::A2UQueryShip* _internal_add_query();
  public:
  const ::A2UQueryShip& query(int index) const;
  ::A2UQueryShip* add_query();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UQueryShip >&
      query() const;

  // repeated .Error error = 6;
  int error_size() const;
  private:
  int _internal_error_size() const;
  public:
  void clear_error();
  ::Error* mutable_error(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Error >*
      mutable_error();
  private:
  const ::Error& _internal_error(int index) const;
  ::Error* _internal_add_error();
  public:
  const ::Error& error(int index) const;
  ::Error* add_error();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Error >&
      error() const;

  // repeated int64 acks = 7;
  int acks_size() const;
  private:
  int _internal_acks_size() const;
  public:
  void clear_acks();
  private:
  int64_t _internal_acks(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_acks() const;
  void _internal_add_acks(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_acks();
  public:
  int64_t acks(int index) const;
  void set_acks(int index, int64_t value);
  void add_acks(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      acks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_acks();

  // optional bool finish = 8;
  bool has_finish() const;
  private:
  bool _internal_has_finish() const;
  public:
  void clear_finish();
  bool finish() const;
  void set_finish(bool value);
  private:
  bool _internal_finish() const;
  void _internal_set_finish(bool value);
  public:

  // @@protoc_insertion_point(class_scope:AmazonCommands)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UAskTruck > gettruck_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UPacked > packed_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2ULoading > loading_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2ULoaded > loaded_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UQueryShip > query_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Error > error_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > acks_;
    bool finish_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// -------------------------------------------------------------------

class UPSCommands final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UPSCommands) */ {
 public:
  inline UPSCommands() : UPSCommands(nullptr) {}
  ~UPSCommands() override;
  explicit PROTOBUF_CONSTEXPR UPSCommands(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UPSCommands(const UPSCommands& from);
  UPSCommands(UPSCommands&& from) noexcept
    : UPSCommands() {
    *this = ::std::move(from);
  }

  inline UPSCommands& operator=(const UPSCommands& from) {
    CopyFrom(from);
    return *this;
  }
  inline UPSCommands& operator=(UPSCommands&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UPSCommands& default_instance() {
    return *internal_default_instance();
  }
  static inline const UPSCommands* internal_default_instance() {
    return reinterpret_cast<const UPSCommands*>(
               &_UPSCommands_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UPSCommands& a, UPSCommands& b) {
    a.Swap(&b);
  }
  inline void Swap(UPSCommands* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UPSCommands* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UPSCommands* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UPSCommands>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UPSCommands& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UPSCommands& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UPSCommands* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UPSCommands";
  }
  protected:
  explicit UPSCommands(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrivedFieldNumber = 1,
    kDeliveringFieldNumber = 2,
    kDeliveredFieldNumber = 3,
    kStatusFieldNumber = 4,
    kAddressFieldNumber = 5,
    kErrorFieldNumber = 6,
    kAcksFieldNumber = 7,
    kFinishFieldNumber = 8,
  };
  // repeated .U2ATruckArrived arrived = 1;
  int arrived_size() const;
  private:
  int _internal_arrived_size() const;
  public:
  void clear_arrived();
  ::U2ATruckArrived* mutable_arrived(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ATruckArrived >*
      mutable_arrived();
  private:
  const ::U2ATruckArrived& _internal_arrived(int index) const;
  ::U2ATruckArrived* _internal_add_arrived();
  public:
  const ::U2ATruckArrived& arrived(int index) const;
  ::U2ATruckArrived* add_arrived();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ATruckArrived >&
      arrived() const;

  // repeated .U2ADelivering delivering = 2;
  int delivering_size() const;
  private:
  int _internal_delivering_size() const;
  public:
  void clear_delivering();
  ::U2ADelivering* mutable_delivering(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ADelivering >*
      mutable_delivering();
  private:
  const ::U2ADelivering& _internal_delivering(int index) const;
  ::U2ADelivering* _internal_add_delivering();
  public:
  const ::U2ADelivering& delivering(int index) const;
  ::U2ADelivering* add_delivering();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ADelivering >&
      delivering() const;

  // repeated .U2ADelivered delivered = 3;
  int delivered_size() const;
  private:
  int _internal_delivered_size() const;
  public:
  void clear_delivered();
  ::U2ADelivered* mutable_delivered(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ADelivered >*
      mutable_delivered();
  private:
  const ::U2ADelivered& _internal_delivered(int index) const;
  ::U2ADelivered* _internal_add_delivered();
  public:
  const ::U2ADelivered& delivered(int index) const;
  ::U2ADelivered* add_delivered();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ADelivered >&
      delivered() const;

  // repeated .U2AShipStatus status = 4;
  int status_size() const;
  private:
  int _internal_status_size() const;
  public:
  void clear_status();
  ::U2AShipStatus* mutable_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2AShipStatus >*
      mutable_status();
  private:
  const ::U2AShipStatus& _internal_status(int index) const;
  ::U2AShipStatus* _internal_add_status();
  public:
  const ::U2AShipStatus& status(int index) const;
  ::U2AShipStatus* add_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2AShipStatus >&
      status() const;

  // repeated .U2AChangeAddress address = 5;
  int address_size() const;
  private:
  int _internal_address_size() const;
  public:
  void clear_address();
  ::U2AChangeAddress* mutable_address(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2AChangeAddress >*
      mutable_address();
  private:
  const ::U2AChangeAddress& _internal_address(int index) const;
  ::U2AChangeAddress* _internal_add_address();
  public:
  const ::U2AChangeAddress& address(int index) const;
  ::U2AChangeAddress* add_address();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2AChangeAddress >&
      address() const;

  // repeated .Error error = 6;
  int error_size() const;
  private:
  int _internal_error_size() const;
  public:
  void clear_error();
  ::Error* mutable_error(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Error >*
      mutable_error();
  private:
  const ::Error& _internal_error(int index) const;
  ::Error* _internal_add_error();
  public:
  const ::Error& error(int index) const;
  ::Error* add_error();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Error >&
      error() const;

  // repeated int64 acks = 7;
  int acks_size() const;
  private:
  int _internal_acks_size() const;
  public:
  void clear_acks();
  private:
  int64_t _internal_acks(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_acks() const;
  void _internal_add_acks(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_acks();
  public:
  int64_t acks(int index) const;
  void set_acks(int index, int64_t value);
  void add_acks(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      acks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_acks();

  // optional bool finish = 8;
  bool has_finish() const;
  private:
  bool _internal_has_finish() const;
  public:
  void clear_finish();
  bool finish() const;
  void set_finish(bool value);
  private:
  bool _internal_finish() const;
  void _internal_set_finish(bool value);
  public:

  // @@protoc_insertion_point(class_scope:UPSCommands)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ATruckArrived > arrived_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ADelivering > delivering_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ADelivered > delivered_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2AShipStatus > status_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2AChangeAddress > address_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Error > error_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > acks_;
    bool finish_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ups_5famazon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// U2AConnect

// required int64 worldid = 1;
inline bool U2AConnect::_internal_has_worldid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool U2AConnect::has_worldid() const {
  return _internal_has_worldid();
}
inline void U2AConnect::clear_worldid() {
  _impl_.worldid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t U2AConnect::_internal_worldid() const {
  return _impl_.worldid_;
}
inline int64_t U2AConnect::worldid() const {
  // @@protoc_insertion_point(field_get:U2AConnect.worldid)
  return _internal_worldid();
}
inline void U2AConnect::_internal_set_worldid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.worldid_ = value;
}
inline void U2AConnect::set_worldid(int64_t value) {
  _internal_set_worldid(value);
  // @@protoc_insertion_point(field_set:U2AConnect.worldid)
}

// -------------------------------------------------------------------

// A2UConnected

// required int64 worldid = 1;
inline bool A2UConnected::_internal_has_worldid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool A2UConnected::has_worldid() const {
  return _internal_has_worldid();
}
inline void A2UConnected::clear_worldid() {
  _impl_.worldid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t A2UConnected::_internal_worldid() const {
  return _impl_.worldid_;
}
inline int64_t A2UConnected::worldid() const {
  // @@protoc_insertion_point(field_get:A2UConnected.worldid)
  return _internal_worldid();
}
inline void A2UConnected::_internal_set_worldid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.worldid_ = value;
}
inline void A2UConnected::set_worldid(int64_t value) {
  _internal_set_worldid(value);
  // @@protoc_insertion_point(field_set:A2UConnected.worldid)
}

// required string result = 2;
inline bool A2UConnected::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool A2UConnected::has_result() const {
  return _internal_has_result();
}
inline void A2UConnected::clear_result() {
  _impl_.result_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& A2UConnected::result() const {
  // @@protoc_insertion_point(field_get:A2UConnected.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void A2UConnected::set_result(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:A2UConnected.result)
}
inline std::string* A2UConnected::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:A2UConnected.result)
  return _s;
}
inline const std::string& A2UConnected::_internal_result() const {
  return _impl_.result_.Get();
}
inline void A2UConnected::_internal_set_result(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* A2UConnected::_internal_mutable_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* A2UConnected::release_result() {
  // @@protoc_insertion_point(field_release:A2UConnected.result)
  if (!_internal_has_result()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.result_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void A2UConnected::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:A2UConnected.result)
}

// -------------------------------------------------------------------

// A2UAskTruck

// required int64 seqnum = 1;
inline bool A2UAskTruck::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool A2UAskTruck::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void A2UAskTruck::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t A2UAskTruck::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t A2UAskTruck::seqnum() const {
  // @@protoc_insertion_point(field_get:A2UAskTruck.seqnum)
  return _internal_seqnum();
}
inline void A2UAskTruck::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.seqnum_ = value;
}
inline void A2UAskTruck::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:A2UAskTruck.seqnum)
}

// required .Warehouse warehouse = 2;
inline bool A2UAskTruck::_internal_has_warehouse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.warehouse_ != nullptr);
  return value;
}
inline bool A2UAskTruck::has_warehouse() const {
  return _internal_has_warehouse();
}
inline void A2UAskTruck::clear_warehouse() {
  if (_impl_.warehouse_ != nullptr) _impl_.warehouse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Warehouse& A2UAskTruck::_internal_warehouse() const {
  const ::Warehouse* p = _impl_.warehouse_;
  return p != nullptr ? *p : reinterpret_cast<const ::Warehouse&>(
      ::_Warehouse_default_instance_);
}
inline const ::Warehouse& A2UAskTruck::warehouse() const {
  // @@protoc_insertion_point(field_get:A2UAskTruck.warehouse)
  return _internal_warehouse();
}
inline void A2UAskTruck::unsafe_arena_set_allocated_warehouse(
    ::Warehouse* warehouse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.warehouse_);
  }
  _impl_.warehouse_ = warehouse;
  if (warehouse) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:A2UAskTruck.warehouse)
}
inline ::Warehouse* A2UAskTruck::release_warehouse() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Warehouse* temp = _impl_.warehouse_;
  _impl_.warehouse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Warehouse* A2UAskTruck::unsafe_arena_release_warehouse() {
  // @@protoc_insertion_point(field_release:A2UAskTruck.warehouse)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Warehouse* temp = _impl_.warehouse_;
  _impl_.warehouse_ = nullptr;
  return temp;
}
inline ::Warehouse* A2UAskTruck::_internal_mutable_warehouse() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.warehouse_ == nullptr) {
    auto* p = CreateMaybeMessage<::Warehouse>(GetArenaForAllocation());
    _impl_.warehouse_ = p;
  }
  return _impl_.warehouse_;
}
inline ::Warehouse* A2UAskTruck::mutable_warehouse() {
  ::Warehouse* _msg = _internal_mutable_warehouse();
  // @@protoc_insertion_point(field_mutable:A2UAskTruck.warehouse)
  return _msg;
}
inline void A2UAskTruck::set_allocated_warehouse(::Warehouse* warehouse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.warehouse_;
  }
  if (warehouse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(warehouse);
    if (message_arena != submessage_arena) {
      warehouse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, warehouse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.warehouse_ = warehouse;
  // @@protoc_insertion_point(field_set_allocated:A2UAskTruck.warehouse)
}

// repeated .PackageInfo package = 3;
inline int A2UAskTruck::_internal_package_size() const {
  return _impl_.package_.size();
}
inline int A2UAskTruck::package_size() const {
  return _internal_package_size();
}
inline void A2UAskTruck::clear_package() {
  _impl_.package_.Clear();
}
inline ::PackageInfo* A2UAskTruck::mutable_package(int index) {
  // @@protoc_insertion_point(field_mutable:A2UAskTruck.package)
  return _impl_.package_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PackageInfo >*
A2UAskTruck::mutable_package() {
  // @@protoc_insertion_point(field_mutable_list:A2UAskTruck.package)
  return &_impl_.package_;
}
inline const ::PackageInfo& A2UAskTruck::_internal_package(int index) const {
  return _impl_.package_.Get(index);
}
inline const ::PackageInfo& A2UAskTruck::package(int index) const {
  // @@protoc_insertion_point(field_get:A2UAskTruck.package)
  return _internal_package(index);
}
inline ::PackageInfo* A2UAskTruck::_internal_add_package() {
  return _impl_.package_.Add();
}
inline ::PackageInfo* A2UAskTruck::add_package() {
  ::PackageInfo* _add = _internal_add_package();
  // @@protoc_insertion_point(field_add:A2UAskTruck.package)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PackageInfo >&
A2UAskTruck::package() const {
  // @@protoc_insertion_point(field_list:A2UAskTruck.package)
  return _impl_.package_;
}

// -------------------------------------------------------------------

// A2UPacked

// required int64 seqnum = 1;
inline bool A2UPacked::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool A2UPacked::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void A2UPacked::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t A2UPacked::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t A2UPacked::seqnum() const {
  // @@protoc_insertion_point(field_get:A2UPacked.seqnum)
  return _internal_seqnum();
}
inline void A2UPacked::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seqnum_ = value;
}
inline void A2UPacked::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:A2UPacked.seqnum)
}

// required int64 shipid = 2;
inline bool A2UPacked::_internal_has_shipid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool A2UPacked::has_shipid() const {
  return _internal_has_shipid();
}
inline void A2UPacked::clear_shipid() {
  _impl_.shipid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t A2UPacked::_internal_shipid() const {
  return _impl_.shipid_;
}
inline int64_t A2UPacked::shipid() const {
  // @@protoc_insertion_point(field_get:A2UPacked.shipid)
  return _internal_shipid();
}
inline void A2UPacked::_internal_set_shipid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.shipid_ = value;
}
inline void A2UPacked::set_shipid(int64_t value) {
  _internal_set_shipid(value);
  // @@protoc_insertion_point(field_set:A2UPacked.shipid)
}

// -------------------------------------------------------------------

// A2ULoading

// required int64 seqnum = 1;
inline bool A2ULoading::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool A2ULoading::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void A2ULoading::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t A2ULoading::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t A2ULoading::seqnum() const {
  // @@protoc_insertion_point(field_get:A2ULoading.seqnum)
  return _internal_seqnum();
}
inline void A2ULoading::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.seqnum_ = value;
}
inline void A2ULoading::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:A2ULoading.seqnum)
}

// required .Warehouse warehouse = 2;
inline bool A2ULoading::_internal_has_warehouse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.warehouse_ != nullptr);
  return value;
}
inline bool A2ULoading::has_warehouse() const {
  return _internal_has_warehouse();
}
inline void A2ULoading::clear_warehouse() {
  if (_impl_.warehouse_ != nullptr) _impl_.warehouse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Warehouse& A2ULoading::_internal_warehouse() const {
  const ::Warehouse* p = _impl_.warehouse_;
  return p != nullptr ? *p : reinterpret_cast<const ::Warehouse&>(
      ::_Warehouse_default_instance_);
}
inline const ::Warehouse& A2ULoading::warehouse() const {
  // @@protoc_insertion_point(field_get:A2ULoading.warehouse)
  return _internal_warehouse();
}
inline void A2ULoading::unsafe_arena_set_allocated_warehouse(
    ::Warehouse* warehouse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.warehouse_);
  }
  _impl_.warehouse_ = warehouse;
  if (warehouse) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:A2ULoading.warehouse)
}
inline ::Warehouse* A2ULoading::release_warehouse() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Warehouse* temp = _impl_.warehouse_;
  _impl_.warehouse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Warehouse* A2ULoading::unsafe_arena_release_warehouse() {
  // @@protoc_insertion_point(field_release:A2ULoading.warehouse)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Warehouse* temp = _impl_.warehouse_;
  _impl_.warehouse_ = nullptr;
  return temp;
}
inline ::Warehouse* A2ULoading::_internal_mutable_warehouse() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.warehouse_ == nullptr) {
    auto* p = CreateMaybeMessage<::Warehouse>(GetArenaForAllocation());
    _impl_.warehouse_ = p;
  }
  return _impl_.warehouse_;
}
inline ::Warehouse* A2ULoading::mutable_warehouse() {
  ::Warehouse* _msg = _internal_mutable_warehouse();
  // @@protoc_insertion_point(field_mutable:A2ULoading.warehouse)
  return _msg;
}
inline void A2ULoading::set_allocated_warehouse(::Warehouse* warehouse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.warehouse_;
  }
  if (warehouse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(warehouse);
    if (message_arena != submessage_arena) {
      warehouse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, warehouse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.warehouse_ = warehouse;
  // @@protoc_insertion_point(field_set_allocated:A2ULoading.warehouse)
}

// required int32 truckid = 3;
inline bool A2ULoading::_internal_has_truckid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool A2ULoading::has_truckid() const {
  return _internal_has_truckid();
}
inline void A2ULoading::clear_truckid() {
  _impl_.truckid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t A2ULoading::_internal_truckid() const {
  return _impl_.truckid_;
}
inline int32_t A2ULoading::truckid() const {
  // @@protoc_insertion_point(field_get:A2ULoading.truckid)
  return _internal_truckid();
}
inline void A2ULoading::_internal_set_truckid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.truckid_ = value;
}
inline void A2ULoading::set_truckid(int32_t value) {
  _internal_set_truckid(value);
  // @@protoc_insertion_point(field_set:A2ULoading.truckid)
}

// repeated int64 shipid = 4;
inline int A2ULoading::_internal_shipid_size() const {
  return _impl_.shipid_.size();
}
inline int A2ULoading::shipid_size() const {
  return _internal_shipid_size();
}
inline void A2ULoading::clear_shipid() {
  _impl_.shipid_.Clear();
}
inline int64_t A2ULoading::_internal_shipid(int index) const {
  return _impl_.shipid_.Get(index);
}
inline int64_t A2ULoading::shipid(int index) const {
  // @@protoc_insertion_point(field_get:A2ULoading.shipid)
  return _internal_shipid(index);
}
inline void A2ULoading::set_shipid(int index, int64_t value) {
  _impl_.shipid_.Set(index, value);
  // @@protoc_insertion_point(field_set:A2ULoading.shipid)
}
inline void A2ULoading::_internal_add_shipid(int64_t value) {
  _impl_.shipid_.Add(value);
}
inline void A2ULoading::add_shipid(int64_t value) {
  _internal_add_shipid(value);
  // @@protoc_insertion_point(field_add:A2ULoading.shipid)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
A2ULoading::_internal_shipid() const {
  return _impl_.shipid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
A2ULoading::shipid() const {
  // @@protoc_insertion_point(field_list:A2ULoading.shipid)
  return _internal_shipid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
A2ULoading::_internal_mutable_shipid() {
  return &_impl_.shipid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
A2ULoading::mutable_shipid() {
  // @@protoc_insertion_point(field_mutable_list:A2ULoading.shipid)
  return _internal_mutable_shipid();
}

// -------------------------------------------------------------------

// A2ULoaded

// required int64 seqnum = 1;
inline bool A2ULoaded::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool A2ULoaded::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void A2ULoaded::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t A2ULoaded::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t A2ULoaded::seqnum() const {
  // @@protoc_insertion_point(field_get:A2ULoaded.seqnum)
  return _internal_seqnum();
}
inline void A2ULoaded::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.seqnum_ = value;
}
inline void A2ULoaded::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:A2ULoaded.seqnum)
}

// required .Warehouse warehouse = 2;
inline bool A2ULoaded::_internal_has_warehouse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.warehouse_ != nullptr);
  return value;
}
inline bool A2ULoaded::has_warehouse() const {
  return _internal_has_warehouse();
}
inline void A2ULoaded::clear_warehouse() {
  if (_impl_.warehouse_ != nullptr) _impl_.warehouse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Warehouse& A2ULoaded::_internal_warehouse() const {
  const ::Warehouse* p = _impl_.warehouse_;
  return p != nullptr ? *p : reinterpret_cast<const ::Warehouse&>(
      ::_Warehouse_default_instance_);
}
inline const ::Warehouse& A2ULoaded::warehouse() const {
  // @@protoc_insertion_point(field_get:A2ULoaded.warehouse)
  return _internal_warehouse();
}
inline void A2ULoaded::unsafe_arena_set_allocated_warehouse(
    ::Warehouse* warehouse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.warehouse_);
  }
  _impl_.warehouse_ = warehouse;
  if (warehouse) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:A2ULoaded.warehouse)
}
inline ::Warehouse* A2ULoaded::release_warehouse() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Warehouse* temp = _impl_.warehouse_;
  _impl_.warehouse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Warehouse* A2ULoaded::unsafe_arena_release_warehouse() {
  // @@protoc_insertion_point(field_release:A2ULoaded.warehouse)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Warehouse* temp = _impl_.warehouse_;
  _impl_.warehouse_ = nullptr;
  return temp;
}
inline ::Warehouse* A2ULoaded::_internal_mutable_warehouse() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.warehouse_ == nullptr) {
    auto* p = CreateMaybeMessage<::Warehouse>(GetArenaForAllocation());
    _impl_.warehouse_ = p;
  }
  return _impl_.warehouse_;
}
inline ::Warehouse* A2ULoaded::mutable_warehouse() {
  ::Warehouse* _msg = _internal_mutable_warehouse();
  // @@protoc_insertion_point(field_mutable:A2ULoaded.warehouse)
  return _msg;
}
inline void A2ULoaded::set_allocated_warehouse(::Warehouse* warehouse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.warehouse_;
  }
  if (warehouse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(warehouse);
    if (message_arena != submessage_arena) {
      warehouse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, warehouse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.warehouse_ = warehouse;
  // @@protoc_insertion_point(field_set_allocated:A2ULoaded.warehouse)
}

// required int32 truckid = 3;
inline bool A2ULoaded::_internal_has_truckid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool A2ULoaded::has_truckid() const {
  return _internal_has_truckid();
}
inline void A2ULoaded::clear_truckid() {
  _impl_.truckid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t A2ULoaded::_internal_truckid() const {
  return _impl_.truckid_;
}
inline int32_t A2ULoaded::truckid() const {
  // @@protoc_insertion_point(field_get:A2ULoaded.truckid)
  return _internal_truckid();
}
inline void A2ULoaded::_internal_set_truckid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.truckid_ = value;
}
inline void A2ULoaded::set_truckid(int32_t value) {
  _internal_set_truckid(value);
  // @@protoc_insertion_point(field_set:A2ULoaded.truckid)
}

// repeated int64 shipid = 4;
inline int A2ULoaded::_internal_shipid_size() const {
  return _impl_.shipid_.size();
}
inline int A2ULoaded::shipid_size() const {
  return _internal_shipid_size();
}
inline void A2ULoaded::clear_shipid() {
  _impl_.shipid_.Clear();
}
inline int64_t A2ULoaded::_internal_shipid(int index) const {
  return _impl_.shipid_.Get(index);
}
inline int64_t A2ULoaded::shipid(int index) const {
  // @@protoc_insertion_point(field_get:A2ULoaded.shipid)
  return _internal_shipid(index);
}
inline void A2ULoaded::set_shipid(int index, int64_t value) {
  _impl_.shipid_.Set(index, value);
  // @@protoc_insertion_point(field_set:A2ULoaded.shipid)
}
inline void A2ULoaded::_internal_add_shipid(int64_t value) {
  _impl_.shipid_.Add(value);
}
inline void A2ULoaded::add_shipid(int64_t value) {
  _internal_add_shipid(value);
  // @@protoc_insertion_point(field_add:A2ULoaded.shipid)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
A2ULoaded::_internal_shipid() const {
  return _impl_.shipid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
A2ULoaded::shipid() const {
  // @@protoc_insertion_point(field_list:A2ULoaded.shipid)
  return _internal_shipid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
A2ULoaded::_internal_mutable_shipid() {
  return &_impl_.shipid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
A2ULoaded::mutable_shipid() {
  // @@protoc_insertion_point(field_mutable_list:A2ULoaded.shipid)
  return _internal_mutable_shipid();
}

// -------------------------------------------------------------------

// U2ATruckArrived

// required int64 seqnum = 1;
inline bool U2ATruckArrived::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool U2ATruckArrived::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void U2ATruckArrived::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t U2ATruckArrived::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t U2ATruckArrived::seqnum() const {
  // @@protoc_insertion_point(field_get:U2ATruckArrived.seqnum)
  return _internal_seqnum();
}
inline void U2ATruckArrived::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.seqnum_ = value;
}
inline void U2ATruckArrived::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:U2ATruckArrived.seqnum)
}

// required .Warehouse warehouse = 2;
inline bool U2ATruckArrived::_internal_has_warehouse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.warehouse_ != nullptr);
  return value;
}
inline bool U2ATruckArrived::has_warehouse() const {
  return _internal_has_warehouse();
}
inline void U2ATruckArrived::clear_warehouse() {
  if (_impl_.warehouse_ != nullptr) _impl_.warehouse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Warehouse& U2ATruckArrived::_internal_warehouse() const {
  const ::Warehouse* p = _impl_.warehouse_;
  return p != nullptr ? *p : reinterpret_cast<const ::Warehouse&>(
      ::_Warehouse_default_instance_);
}
inline const ::Warehouse& U2ATruckArrived::warehouse() const {
  // @@protoc_insertion_point(field_get:U2ATruckArrived.warehouse)
  return _internal_warehouse();
}
inline void U2ATruckArrived::unsafe_arena_set_allocated_warehouse(
    ::Warehouse* warehouse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.warehouse_);
  }
  _impl_.warehouse_ = warehouse;
  if (warehouse) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:U2ATruckArrived.warehouse)
}
inline ::Warehouse* U2ATruckArrived::release_warehouse() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Warehouse* temp = _impl_.warehouse_;
  _impl_.warehouse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Warehouse* U2ATruckArrived::unsafe_arena_release_warehouse() {
  // @@protoc_insertion_point(field_release:U2ATruckArrived.warehouse)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Warehouse* temp = _impl_.warehouse_;
  _impl_.warehouse_ = nullptr;
  return temp;
}
inline ::Warehouse* U2ATruckArrived::_internal_mutable_warehouse() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.warehouse_ == nullptr) {
    auto* p = CreateMaybeMessage<::Warehouse>(GetArenaForAllocation());
    _impl_.warehouse_ = p;
  }
  return _impl_.warehouse_;
}
inline ::Warehouse* U2ATruckArrived::mutable_warehouse() {
  ::Warehouse* _msg = _internal_mutable_warehouse();
  // @@protoc_insertion_point(field_mutable:U2ATruckArrived.warehouse)
  return _msg;
}
inline void U2ATruckArrived::set_allocated_warehouse(::Warehouse* warehouse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.warehouse_;
  }
  if (warehouse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(warehouse);
    if (message_arena != submessage_arena) {
      warehouse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, warehouse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.warehouse_ = warehouse;
  // @@protoc_insertion_point(field_set_allocated:U2ATruckArrived.warehouse)
}

// required int32 truckid = 3;
inline bool U2ATruckArrived::_internal_has_truckid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool U2ATruckArrived::has_truckid() const {
  return _internal_has_truckid();
}
inline void U2ATruckArrived::clear_truckid() {
  _impl_.truckid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t U2ATruckArrived::_internal_truckid() const {
  return _impl_.truckid_;
}
inline int32_t U2ATruckArrived::truckid() const {
  // @@protoc_insertion_point(field_get:U2ATruckArrived.truckid)
  return _internal_truckid();
}
inline void U2ATruckArrived::_internal_set_truckid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.truckid_ = value;
}
inline void U2ATruckArrived::set_truckid(int32_t value) {
  _internal_set_truckid(value);
  // @@protoc_insertion_point(field_set:U2ATruckArrived.truckid)
}

// repeated int64 shipid = 4;
inline int U2ATruckArrived::_internal_shipid_size() const {
  return _impl_.shipid_.size();
}
inline int U2ATruckArrived::shipid_size() const {
  return _internal_shipid_size();
}
inline void U2ATruckArrived::clear_shipid() {
  _impl_.shipid_.Clear();
}
inline int64_t U2ATruckArrived::_internal_shipid(int index) const {
  return _impl_.shipid_.Get(index);
}
inline int64_t U2ATruckArrived::shipid(int index) const {
  // @@protoc_insertion_point(field_get:U2ATruckArrived.shipid)
  return _internal_shipid(index);
}
inline void U2ATruckArrived::set_shipid(int index, int64_t value) {
  _impl_.shipid_.Set(index, value);
  // @@protoc_insertion_point(field_set:U2ATruckArrived.shipid)
}
inline void U2ATruckArrived::_internal_add_shipid(int64_t value) {
  _impl_.shipid_.Add(value);
}
inline void U2ATruckArrived::add_shipid(int64_t value) {
  _internal_add_shipid(value);
  // @@protoc_insertion_point(field_add:U2ATruckArrived.shipid)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
U2ATruckArrived::_internal_shipid() const {
  return _impl_.shipid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
U2ATruckArrived::shipid() const {
  // @@protoc_insertion_point(field_list:U2ATruckArrived.shipid)
  return _internal_shipid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
U2ATruckArrived::_internal_mutable_shipid() {
  return &_impl_.shipid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
U2ATruckArrived::mutable_shipid() {
  // @@protoc_insertion_point(field_mutable_list:U2ATruckArrived.shipid)
  return _internal_mutable_shipid();
}

// -------------------------------------------------------------------

// U2ADelivering

// required int64 seqnum = 1;
inline bool U2ADelivering::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool U2ADelivering::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void U2ADelivering::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t U2ADelivering::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t U2ADelivering::seqnum() const {
  // @@protoc_insertion_point(field_get:U2ADelivering.seqnum)
  return _internal_seqnum();
}
inline void U2ADelivering::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seqnum_ = value;
}
inline void U2ADelivering::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:U2ADelivering.seqnum)
}

// repeated int64 shipid = 2;
inline int U2ADelivering::_internal_shipid_size() const {
  return _impl_.shipid_.size();
}
inline int U2ADelivering::shipid_size() const {
  return _internal_shipid_size();
}
inline void U2ADelivering::clear_shipid() {
  _impl_.shipid_.Clear();
}
inline int64_t U2ADelivering::_internal_shipid(int index) const {
  return _impl_.shipid_.Get(index);
}
inline int64_t U2ADelivering::shipid(int index) const {
  // @@protoc_insertion_point(field_get:U2ADelivering.shipid)
  return _internal_shipid(index);
}
inline void U2ADelivering::set_shipid(int index, int64_t value) {
  _impl_.shipid_.Set(index, value);
  // @@protoc_insertion_point(field_set:U2ADelivering.shipid)
}
inline void U2ADelivering::_internal_add_shipid(int64_t value) {
  _impl_.shipid_.Add(value);
}
inline void U2ADelivering::add_shipid(int64_t value) {
  _internal_add_shipid(value);
  // @@protoc_insertion_point(field_add:U2ADelivering.shipid)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
U2ADelivering::_internal_shipid() const {
  return _impl_.shipid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
U2ADelivering::shipid() const {
  // @@protoc_insertion_point(field_list:U2ADelivering.shipid)
  return _internal_shipid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
U2ADelivering::_internal_mutable_shipid() {
  return &_impl_.shipid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
U2ADelivering::mutable_shipid() {
  // @@protoc_insertion_point(field_mutable_list:U2ADelivering.shipid)
  return _internal_mutable_shipid();
}

// required int32 truckid = 3;
inline bool U2ADelivering::_internal_has_truckid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool U2ADelivering::has_truckid() const {
  return _internal_has_truckid();
}
inline void U2ADelivering::clear_truckid() {
  _impl_.truckid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t U2ADelivering::_internal_truckid() const {
  return _impl_.truckid_;
}
inline int32_t U2ADelivering::truckid() const {
  // @@protoc_insertion_point(field_get:U2ADelivering.truckid)
  return _internal_truckid();
}
inline void U2ADelivering::_internal_set_truckid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.truckid_ = value;
}
inline void U2ADelivering::set_truckid(int32_t value) {
  _internal_set_truckid(value);
  // @@protoc_insertion_point(field_set:U2ADelivering.truckid)
}

// -------------------------------------------------------------------

// U2ADelivered

// required int64 seqnum = 1;
inline bool U2ADelivered::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool U2ADelivered::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void U2ADelivered::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t U2ADelivered::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t U2ADelivered::seqnum() const {
  // @@protoc_insertion_point(field_get:U2ADelivered.seqnum)
  return _internal_seqnum();
}
inline void U2ADelivered::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seqnum_ = value;
}
inline void U2ADelivered::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:U2ADelivered.seqnum)
}

// repeated int64 shipid = 2;
inline int U2ADelivered::_internal_shipid_size() const {
  return _impl_.shipid_.size();
}
inline int U2ADelivered::shipid_size() const {
  return _internal_shipid_size();
}
inline void U2ADelivered::clear_shipid() {
  _impl_.shipid_.Clear();
}
inline int64_t U2ADelivered::_internal_shipid(int index) const {
  return _impl_.shipid_.Get(index);
}
inline int64_t U2ADelivered::shipid(int index) const {
  // @@protoc_insertion_point(field_get:U2ADelivered.shipid)
  return _internal_shipid(index);
}
inline void U2ADelivered::set_shipid(int index, int64_t value) {
  _impl_.shipid_.Set(index, value);
  // @@protoc_insertion_point(field_set:U2ADelivered.shipid)
}
inline void U2ADelivered::_internal_add_shipid(int64_t value) {
  _impl_.shipid_.Add(value);
}
inline void U2ADelivered::add_shipid(int64_t value) {
  _internal_add_shipid(value);
  // @@protoc_insertion_point(field_add:U2ADelivered.shipid)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
U2ADelivered::_internal_shipid() const {
  return _impl_.shipid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
U2ADelivered::shipid() const {
  // @@protoc_insertion_point(field_list:U2ADelivered.shipid)
  return _internal_shipid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
U2ADelivered::_internal_mutable_shipid() {
  return &_impl_.shipid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
U2ADelivered::mutable_shipid() {
  // @@protoc_insertion_point(field_mutable_list:U2ADelivered.shipid)
  return _internal_mutable_shipid();
}

// -------------------------------------------------------------------

// PackageInfo

// required int64 shipid = 1;
inline bool PackageInfo::_internal_has_shipid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PackageInfo::has_shipid() const {
  return _internal_has_shipid();
}
inline void PackageInfo::clear_shipid() {
  _impl_.shipid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t PackageInfo::_internal_shipid() const {
  return _impl_.shipid_;
}
inline int64_t PackageInfo::shipid() const {
  // @@protoc_insertion_point(field_get:PackageInfo.shipid)
  return _internal_shipid();
}
inline void PackageInfo::_internal_set_shipid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.shipid_ = value;
}
inline void PackageInfo::set_shipid(int64_t value) {
  _internal_set_shipid(value);
  // @@protoc_insertion_point(field_set:PackageInfo.shipid)
}

// required int32 x = 2;
inline bool PackageInfo::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PackageInfo::has_x() const {
  return _internal_has_x();
}
inline void PackageInfo::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t PackageInfo::_internal_x() const {
  return _impl_.x_;
}
inline int32_t PackageInfo::x() const {
  // @@protoc_insertion_point(field_get:PackageInfo.x)
  return _internal_x();
}
inline void PackageInfo::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.x_ = value;
}
inline void PackageInfo::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:PackageInfo.x)
}

// required int32 y = 3;
inline bool PackageInfo::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PackageInfo::has_y() const {
  return _internal_has_y();
}
inline void PackageInfo::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t PackageInfo::_internal_y() const {
  return _impl_.y_;
}
inline int32_t PackageInfo::y() const {
  // @@protoc_insertion_point(field_get:PackageInfo.y)
  return _internal_y();
}
inline void PackageInfo::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.y_ = value;
}
inline void PackageInfo::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:PackageInfo.y)
}

// optional string user_name = 4;
inline bool PackageInfo::_internal_has_user_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PackageInfo::has_user_name() const {
  return _internal_has_user_name();
}
inline void PackageInfo::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PackageInfo::user_name() const {
  // @@protoc_insertion_point(field_get:PackageInfo.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PackageInfo::set_user_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PackageInfo.user_name)
}
inline std::string* PackageInfo::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:PackageInfo.user_name)
  return _s;
}
inline const std::string& PackageInfo::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void PackageInfo::_internal_set_user_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PackageInfo::_internal_mutable_user_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PackageInfo::release_user_name() {
  // @@protoc_insertion_point(field_release:PackageInfo.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PackageInfo::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PackageInfo.user_name)
}

// repeated .Product product = 5;
inline int PackageInfo::_internal_product_size() const {
  return _impl_.product_.size();
}
inline int PackageInfo::product_size() const {
  return _internal_product_size();
}
inline void PackageInfo::clear_product() {
  _impl_.product_.Clear();
}
inline ::Product* PackageInfo::mutable_product(int index) {
  // @@protoc_insertion_point(field_mutable:PackageInfo.product)
  return _impl_.product_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Product >*
PackageInfo::mutable_product() {
  // @@protoc_insertion_point(field_mutable_list:PackageInfo.product)
  return &_impl_.product_;
}
inline const ::Product& PackageInfo::_internal_product(int index) const {
  return _impl_.product_.Get(index);
}
inline const ::Product& PackageInfo::product(int index) const {
  // @@protoc_insertion_point(field_get:PackageInfo.product)
  return _internal_product(index);
}
inline ::Product* PackageInfo::_internal_add_product() {
  return _impl_.product_.Add();
}
inline ::Product* PackageInfo::add_product() {
  ::Product* _add = _internal_add_product();
  // @@protoc_insertion_point(field_add:PackageInfo.product)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Product >&
PackageInfo::product() const {
  // @@protoc_insertion_point(field_list:PackageInfo.product)
  return _impl_.product_;
}

// -------------------------------------------------------------------

// Product

// required string name = 1;
inline bool Product::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Product::has_name() const {
  return _internal_has_name();
}
inline void Product::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Product::name() const {
  // @@protoc_insertion_point(field_get:Product.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Product::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Product.name)
}
inline std::string* Product::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Product.name)
  return _s;
}
inline const std::string& Product::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Product::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Product::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Product::release_name() {
  // @@protoc_insertion_point(field_release:Product.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Product::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Product.name)
}

// required string description = 2;
inline bool Product::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Product::has_description() const {
  return _internal_has_description();
}
inline void Product::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Product::description() const {
  // @@protoc_insertion_point(field_get:Product.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Product::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Product.description)
}
inline std::string* Product::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:Product.description)
  return _s;
}
inline const std::string& Product::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Product::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Product::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Product::release_description() {
  // @@protoc_insertion_point(field_release:Product.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Product::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Product.description)
}

// required int32 count = 3;
inline bool Product::_internal_has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Product::has_count() const {
  return _internal_has_count();
}
inline void Product::clear_count() {
  _impl_.count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Product::_internal_count() const {
  return _impl_.count_;
}
inline int32_t Product::count() const {
  // @@protoc_insertion_point(field_get:Product.count)
  return _internal_count();
}
inline void Product::_internal_set_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.count_ = value;
}
inline void Product::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:Product.count)
}

// -------------------------------------------------------------------

// Warehouse

// required int32 warehouseid = 1;
inline bool Warehouse::_internal_has_warehouseid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Warehouse::has_warehouseid() const {
  return _internal_has_warehouseid();
}
inline void Warehouse::clear_warehouseid() {
  _impl_.warehouseid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Warehouse::_internal_warehouseid() const {
  return _impl_.warehouseid_;
}
inline int32_t Warehouse::warehouseid() const {
  // @@protoc_insertion_point(field_get:Warehouse.warehouseid)
  return _internal_warehouseid();
}
inline void Warehouse::_internal_set_warehouseid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.warehouseid_ = value;
}
inline void Warehouse::set_warehouseid(int32_t value) {
  _internal_set_warehouseid(value);
  // @@protoc_insertion_point(field_set:Warehouse.warehouseid)
}

// required int32 x = 2;
inline bool Warehouse::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Warehouse::has_x() const {
  return _internal_has_x();
}
inline void Warehouse::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Warehouse::_internal_x() const {
  return _impl_.x_;
}
inline int32_t Warehouse::x() const {
  // @@protoc_insertion_point(field_get:Warehouse.x)
  return _internal_x();
}
inline void Warehouse::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.x_ = value;
}
inline void Warehouse::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Warehouse.x)
}

// required int32 y = 3;
inline bool Warehouse::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Warehouse::has_y() const {
  return _internal_has_y();
}
inline void Warehouse::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Warehouse::_internal_y() const {
  return _impl_.y_;
}
inline int32_t Warehouse::y() const {
  // @@protoc_insertion_point(field_get:Warehouse.y)
  return _internal_y();
}
inline void Warehouse::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.y_ = value;
}
inline void Warehouse::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Warehouse.y)
}

// -------------------------------------------------------------------

// Error

// required int64 seqnum = 1;
inline bool Error::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Error::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void Error::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t Error::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t Error::seqnum() const {
  // @@protoc_insertion_point(field_get:Error.seqnum)
  return _internal_seqnum();
}
inline void Error::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.seqnum_ = value;
}
inline void Error::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:Error.seqnum)
}

// required int64 originseqnum = 2;
inline bool Error::_internal_has_originseqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Error::has_originseqnum() const {
  return _internal_has_originseqnum();
}
inline void Error::clear_originseqnum() {
  _impl_.originseqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t Error::_internal_originseqnum() const {
  return _impl_.originseqnum_;
}
inline int64_t Error::originseqnum() const {
  // @@protoc_insertion_point(field_get:Error.originseqnum)
  return _internal_originseqnum();
}
inline void Error::_internal_set_originseqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.originseqnum_ = value;
}
inline void Error::set_originseqnum(int64_t value) {
  _internal_set_originseqnum(value);
  // @@protoc_insertion_point(field_set:Error.originseqnum)
}

// optional string info = 3;
inline bool Error::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Error::has_info() const {
  return _internal_has_info();
}
inline void Error::clear_info() {
  _impl_.info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Error::info() const {
  // @@protoc_insertion_point(field_get:Error.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_info(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Error.info)
}
inline std::string* Error::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Error.info)
  return _s;
}
inline const std::string& Error::_internal_info() const {
  return _impl_.info_.Get();
}
inline void Error::_internal_set_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.info_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.info_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_info() {
  // @@protoc_insertion_point(field_release:Error.info)
  if (!_internal_has_info()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.info_.IsDefault()) {
    _impl_.info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Error::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.info_.SetAllocated(info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.info_.IsDefault()) {
    _impl_.info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Error.info)
}

// -------------------------------------------------------------------

// A2UQueryShip

// required int64 seqnum = 1;
inline bool A2UQueryShip::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool A2UQueryShip::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void A2UQueryShip::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t A2UQueryShip::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t A2UQueryShip::seqnum() const {
  // @@protoc_insertion_point(field_get:A2UQueryShip.seqnum)
  return _internal_seqnum();
}
inline void A2UQueryShip::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seqnum_ = value;
}
inline void A2UQueryShip::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:A2UQueryShip.seqnum)
}

// required int64 shipid = 2;
inline bool A2UQueryShip::_internal_has_shipid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool A2UQueryShip::has_shipid() const {
  return _internal_has_shipid();
}
inline void A2UQueryShip::clear_shipid() {
  _impl_.shipid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t A2UQueryShip::_internal_shipid() const {
  return _impl_.shipid_;
}
inline int64_t A2UQueryShip::shipid() const {
  // @@protoc_insertion_point(field_get:A2UQueryShip.shipid)
  return _internal_shipid();
}
inline void A2UQueryShip::_internal_set_shipid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.shipid_ = value;
}
inline void A2UQueryShip::set_shipid(int64_t value) {
  _internal_set_shipid(value);
  // @@protoc_insertion_point(field_set:A2UQueryShip.shipid)
}

// -------------------------------------------------------------------

// U2AShipStatus

// required int64 seqnum = 1;
inline bool U2AShipStatus::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool U2AShipStatus::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void U2AShipStatus::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t U2AShipStatus::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t U2AShipStatus::seqnum() const {
  // @@protoc_insertion_point(field_get:U2AShipStatus.seqnum)
  return _internal_seqnum();
}
inline void U2AShipStatus::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.seqnum_ = value;
}
inline void U2AShipStatus::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:U2AShipStatus.seqnum)
}

// required int64 shipid = 2;
inline bool U2AShipStatus::_internal_has_shipid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool U2AShipStatus::has_shipid() const {
  return _internal_has_shipid();
}
inline void U2AShipStatus::clear_shipid() {
  _impl_.shipid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t U2AShipStatus::_internal_shipid() const {
  return _impl_.shipid_;
}
inline int64_t U2AShipStatus::shipid() const {
  // @@protoc_insertion_point(field_get:U2AShipStatus.shipid)
  return _internal_shipid();
}
inline void U2AShipStatus::_internal_set_shipid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.shipid_ = value;
}
inline void U2AShipStatus::set_shipid(int64_t value) {
  _internal_set_shipid(value);
  // @@protoc_insertion_point(field_set:U2AShipStatus.shipid)
}

// required string status = 3;
inline bool U2AShipStatus::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool U2AShipStatus::has_status() const {
  return _internal_has_status();
}
inline void U2AShipStatus::clear_status() {
  _impl_.status_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& U2AShipStatus::status() const {
  // @@protoc_insertion_point(field_get:U2AShipStatus.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void U2AShipStatus::set_status(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:U2AShipStatus.status)
}
inline std::string* U2AShipStatus::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:U2AShipStatus.status)
  return _s;
}
inline const std::string& U2AShipStatus::_internal_status() const {
  return _impl_.status_.Get();
}
inline void U2AShipStatus::_internal_set_status(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* U2AShipStatus::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* U2AShipStatus::release_status() {
  // @@protoc_insertion_point(field_release:U2AShipStatus.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.status_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void U2AShipStatus::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:U2AShipStatus.status)
}

// -------------------------------------------------------------------

// U2AChangeAddress

// required int64 seqnum = 1;
inline bool U2AChangeAddress::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool U2AChangeAddress::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void U2AChangeAddress::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t U2AChangeAddress::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t U2AChangeAddress::seqnum() const {
  // @@protoc_insertion_point(field_get:U2AChangeAddress.seqnum)
  return _internal_seqnum();
}
inline void U2AChangeAddress::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seqnum_ = value;
}
inline void U2AChangeAddress::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:U2AChangeAddress.seqnum)
}

// required int64 shipid = 2;
inline bool U2AChangeAddress::_internal_has_shipid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool U2AChangeAddress::has_shipid() const {
  return _internal_has_shipid();
}
inline void U2AChangeAddress::clear_shipid() {
  _impl_.shipid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t U2AChangeAddress::_internal_shipid() const {
  return _impl_.shipid_;
}
inline int64_t U2AChangeAddress::shipid() const {
  // @@protoc_insertion_point(field_get:U2AChangeAddress.shipid)
  return _internal_shipid();
}
inline void U2AChangeAddress::_internal_set_shipid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.shipid_ = value;
}
inline void U2AChangeAddress::set_shipid(int64_t value) {
  _internal_set_shipid(value);
  // @@protoc_insertion_point(field_set:U2AChangeAddress.shipid)
}

// required int32 x = 3;
inline bool U2AChangeAddress::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool U2AChangeAddress::has_x() const {
  return _internal_has_x();
}
inline void U2AChangeAddress::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t U2AChangeAddress::_internal_x() const {
  return _impl_.x_;
}
inline int32_t U2AChangeAddress::x() const {
  // @@protoc_insertion_point(field_get:U2AChangeAddress.x)
  return _internal_x();
}
inline void U2AChangeAddress::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.x_ = value;
}
inline void U2AChangeAddress::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:U2AChangeAddress.x)
}

// required int32 y = 4;
inline bool U2AChangeAddress::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool U2AChangeAddress::has_y() const {
  return _internal_has_y();
}
inline void U2AChangeAddress::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t U2AChangeAddress::_internal_y() const {
  return _impl_.y_;
}
inline int32_t U2AChangeAddress::y() const {
  // @@protoc_insertion_point(field_get:U2AChangeAddress.y)
  return _internal_y();
}
inline void U2AChangeAddress::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.y_ = value;
}
inline void U2AChangeAddress::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:U2AChangeAddress.y)
}

// -------------------------------------------------------------------

// AmazonCommands

// repeated .A2UAskTruck getTruck = 1;
inline int AmazonCommands::_internal_gettruck_size() const {
  return _impl_.gettruck_.size();
}
inline int AmazonCommands::gettruck_size() const {
  return _internal_gettruck_size();
}
inline void AmazonCommands::clear_gettruck() {
  _impl_.gettruck_.Clear();
}
inline ::A2UAskTruck* AmazonCommands::mutable_gettruck(int index) {
  // @@protoc_insertion_point(field_mutable:AmazonCommands.getTruck)
  return _impl_.gettruck_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UAskTruck >*
AmazonCommands::mutable_gettruck() {
  // @@protoc_insertion_point(field_mutable_list:AmazonCommands.getTruck)
  return &_impl_.gettruck_;
}
inline const ::A2UAskTruck& AmazonCommands::_internal_gettruck(int index) const {
  return _impl_.gettruck_.Get(index);
}
inline const ::A2UAskTruck& AmazonCommands::gettruck(int index) const {
  // @@protoc_insertion_point(field_get:AmazonCommands.getTruck)
  return _internal_gettruck(index);
}
inline ::A2UAskTruck* AmazonCommands::_internal_add_gettruck() {
  return _impl_.gettruck_.Add();
}
inline ::A2UAskTruck* AmazonCommands::add_gettruck() {
  ::A2UAskTruck* _add = _internal_add_gettruck();
  // @@protoc_insertion_point(field_add:AmazonCommands.getTruck)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UAskTruck >&
AmazonCommands::gettruck() const {
  // @@protoc_insertion_point(field_list:AmazonCommands.getTruck)
  return _impl_.gettruck_;
}

// repeated .A2UPacked packed = 2;
inline int AmazonCommands::_internal_packed_size() const {
  return _impl_.packed_.size();
}
inline int AmazonCommands::packed_size() const {
  return _internal_packed_size();
}
inline void AmazonCommands::clear_packed() {
  _impl_.packed_.Clear();
}
inline ::A2UPacked* AmazonCommands::mutable_packed(int index) {
  // @@protoc_insertion_point(field_mutable:AmazonCommands.packed)
  return _impl_.packed_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UPacked >*
AmazonCommands::mutable_packed() {
  // @@protoc_insertion_point(field_mutable_list:AmazonCommands.packed)
  return &_impl_.packed_;
}
inline const ::A2UPacked& AmazonCommands::_internal_packed(int index) const {
  return _impl_.packed_.Get(index);
}
inline const ::A2UPacked& AmazonCommands::packed(int index) const {
  // @@protoc_insertion_point(field_get:AmazonCommands.packed)
  return _internal_packed(index);
}
inline ::A2UPacked* AmazonCommands::_internal_add_packed() {
  return _impl_.packed_.Add();
}
inline ::A2UPacked* AmazonCommands::add_packed() {
  ::A2UPacked* _add = _internal_add_packed();
  // @@protoc_insertion_point(field_add:AmazonCommands.packed)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UPacked >&
AmazonCommands::packed() const {
  // @@protoc_insertion_point(field_list:AmazonCommands.packed)
  return _impl_.packed_;
}

// repeated .A2ULoading loading = 3;
inline int AmazonCommands::_internal_loading_size() const {
  return _impl_.loading_.size();
}
inline int AmazonCommands::loading_size() const {
  return _internal_loading_size();
}
inline void AmazonCommands::clear_loading() {
  _impl_.loading_.Clear();
}
inline ::A2ULoading* AmazonCommands::mutable_loading(int index) {
  // @@protoc_insertion_point(field_mutable:AmazonCommands.loading)
  return _impl_.loading_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2ULoading >*
AmazonCommands::mutable_loading() {
  // @@protoc_insertion_point(field_mutable_list:AmazonCommands.loading)
  return &_impl_.loading_;
}
inline const ::A2ULoading& AmazonCommands::_internal_loading(int index) const {
  return _impl_.loading_.Get(index);
}
inline const ::A2ULoading& AmazonCommands::loading(int index) const {
  // @@protoc_insertion_point(field_get:AmazonCommands.loading)
  return _internal_loading(index);
}
inline ::A2ULoading* AmazonCommands::_internal_add_loading() {
  return _impl_.loading_.Add();
}
inline ::A2ULoading* AmazonCommands::add_loading() {
  ::A2ULoading* _add = _internal_add_loading();
  // @@protoc_insertion_point(field_add:AmazonCommands.loading)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2ULoading >&
AmazonCommands::loading() const {
  // @@protoc_insertion_point(field_list:AmazonCommands.loading)
  return _impl_.loading_;
}

// repeated .A2ULoaded loaded = 4;
inline int AmazonCommands::_internal_loaded_size() const {
  return _impl_.loaded_.size();
}
inline int AmazonCommands::loaded_size() const {
  return _internal_loaded_size();
}
inline void AmazonCommands::clear_loaded() {
  _impl_.loaded_.Clear();
}
inline ::A2ULoaded* AmazonCommands::mutable_loaded(int index) {
  // @@protoc_insertion_point(field_mutable:AmazonCommands.loaded)
  return _impl_.loaded_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2ULoaded >*
AmazonCommands::mutable_loaded() {
  // @@protoc_insertion_point(field_mutable_list:AmazonCommands.loaded)
  return &_impl_.loaded_;
}
inline const ::A2ULoaded& AmazonCommands::_internal_loaded(int index) const {
  return _impl_.loaded_.Get(index);
}
inline const ::A2ULoaded& AmazonCommands::loaded(int index) const {
  // @@protoc_insertion_point(field_get:AmazonCommands.loaded)
  return _internal_loaded(index);
}
inline ::A2ULoaded* AmazonCommands::_internal_add_loaded() {
  return _impl_.loaded_.Add();
}
inline ::A2ULoaded* AmazonCommands::add_loaded() {
  ::A2ULoaded* _add = _internal_add_loaded();
  // @@protoc_insertion_point(field_add:AmazonCommands.loaded)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2ULoaded >&
AmazonCommands::loaded() const {
  // @@protoc_insertion_point(field_list:AmazonCommands.loaded)
  return _impl_.loaded_;
}

// repeated .A2UQueryShip query = 5;
inline int AmazonCommands::_internal_query_size() const {
  return _impl_.query_.size();
}
inline int AmazonCommands::query_size() const {
  return _internal_query_size();
}
inline void AmazonCommands::clear_query() {
  _impl_.query_.Clear();
}
inline ::A2UQueryShip* AmazonCommands::mutable_query(int index) {
  // @@protoc_insertion_point(field_mutable:AmazonCommands.query)
  return _impl_.query_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UQueryShip >*
AmazonCommands::mutable_query() {
  // @@protoc_insertion_point(field_mutable_list:AmazonCommands.query)
  return &_impl_.query_;
}
inline const ::A2UQueryShip& AmazonCommands::_internal_query(int index) const {
  return _impl_.query_.Get(index);
}
inline const ::A2UQueryShip& AmazonCommands::query(int index) const {
  // @@protoc_insertion_point(field_get:AmazonCommands.query)
  return _internal_query(index);
}
inline ::A2UQueryShip* AmazonCommands::_internal_add_query() {
  return _impl_.query_.Add();
}
inline ::A2UQueryShip* AmazonCommands::add_query() {
  ::A2UQueryShip* _add = _internal_add_query();
  // @@protoc_insertion_point(field_add:AmazonCommands.query)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::A2UQueryShip >&
AmazonCommands::query() const {
  // @@protoc_insertion_point(field_list:AmazonCommands.query)
  return _impl_.query_;
}

// repeated .Error error = 6;
inline int AmazonCommands::_internal_error_size() const {
  return _impl_.error_.size();
}
inline int AmazonCommands::error_size() const {
  return _internal_error_size();
}
inline void AmazonCommands::clear_error() {
  _impl_.error_.Clear();
}
inline ::Error* AmazonCommands::mutable_error(int index) {
  // @@protoc_insertion_point(field_mutable:AmazonCommands.error)
  return _impl_.error_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Error >*
AmazonCommands::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:AmazonCommands.error)
  return &_impl_.error_;
}
inline const ::Error& AmazonCommands::_internal_error(int index) const {
  return _impl_.error_.Get(index);
}
inline const ::Error& AmazonCommands::error(int index) const {
  // @@protoc_insertion_point(field_get:AmazonCommands.error)
  return _internal_error(index);
}
inline ::Error* AmazonCommands::_internal_add_error() {
  return _impl_.error_.Add();
}
inline ::Error* AmazonCommands::add_error() {
  ::Error* _add = _internal_add_error();
  // @@protoc_insertion_point(field_add:AmazonCommands.error)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Error >&
AmazonCommands::error() const {
  // @@protoc_insertion_point(field_list:AmazonCommands.error)
  return _impl_.error_;
}

// repeated int64 acks = 7;
inline int AmazonCommands::_internal_acks_size() const {
  return _impl_.acks_.size();
}
inline int AmazonCommands::acks_size() const {
  return _internal_acks_size();
}
inline void AmazonCommands::clear_acks() {
  _impl_.acks_.Clear();
}
inline int64_t AmazonCommands::_internal_acks(int index) const {
  return _impl_.acks_.Get(index);
}
inline int64_t AmazonCommands::acks(int index) const {
  // @@protoc_insertion_point(field_get:AmazonCommands.acks)
  return _internal_acks(index);
}
inline void AmazonCommands::set_acks(int index, int64_t value) {
  _impl_.acks_.Set(index, value);
  // @@protoc_insertion_point(field_set:AmazonCommands.acks)
}
inline void AmazonCommands::_internal_add_acks(int64_t value) {
  _impl_.acks_.Add(value);
}
inline void AmazonCommands::add_acks(int64_t value) {
  _internal_add_acks(value);
  // @@protoc_insertion_point(field_add:AmazonCommands.acks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
AmazonCommands::_internal_acks() const {
  return _impl_.acks_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
AmazonCommands::acks() const {
  // @@protoc_insertion_point(field_list:AmazonCommands.acks)
  return _internal_acks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
AmazonCommands::_internal_mutable_acks() {
  return &_impl_.acks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
AmazonCommands::mutable_acks() {
  // @@protoc_insertion_point(field_mutable_list:AmazonCommands.acks)
  return _internal_mutable_acks();
}

// optional bool finish = 8;
inline bool AmazonCommands::_internal_has_finish() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AmazonCommands::has_finish() const {
  return _internal_has_finish();
}
inline void AmazonCommands::clear_finish() {
  _impl_.finish_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AmazonCommands::_internal_finish() const {
  return _impl_.finish_;
}
inline bool AmazonCommands::finish() const {
  // @@protoc_insertion_point(field_get:AmazonCommands.finish)
  return _internal_finish();
}
inline void AmazonCommands::_internal_set_finish(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.finish_ = value;
}
inline void AmazonCommands::set_finish(bool value) {
  _internal_set_finish(value);
  // @@protoc_insertion_point(field_set:AmazonCommands.finish)
}

// -------------------------------------------------------------------

// UPSCommands

// repeated .U2ATruckArrived arrived = 1;
inline int UPSCommands::_internal_arrived_size() const {
  return _impl_.arrived_.size();
}
inline int UPSCommands::arrived_size() const {
  return _internal_arrived_size();
}
inline void UPSCommands::clear_arrived() {
  _impl_.arrived_.Clear();
}
inline ::U2ATruckArrived* UPSCommands::mutable_arrived(int index) {
  // @@protoc_insertion_point(field_mutable:UPSCommands.arrived)
  return _impl_.arrived_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ATruckArrived >*
UPSCommands::mutable_arrived() {
  // @@protoc_insertion_point(field_mutable_list:UPSCommands.arrived)
  return &_impl_.arrived_;
}
inline const ::U2ATruckArrived& UPSCommands::_internal_arrived(int index) const {
  return _impl_.arrived_.Get(index);
}
inline const ::U2ATruckArrived& UPSCommands::arrived(int index) const {
  // @@protoc_insertion_point(field_get:UPSCommands.arrived)
  return _internal_arrived(index);
}
inline ::U2ATruckArrived* UPSCommands::_internal_add_arrived() {
  return _impl_.arrived_.Add();
}
inline ::U2ATruckArrived* UPSCommands::add_arrived() {
  ::U2ATruckArrived* _add = _internal_add_arrived();
  // @@protoc_insertion_point(field_add:UPSCommands.arrived)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ATruckArrived >&
UPSCommands::arrived() const {
  // @@protoc_insertion_point(field_list:UPSCommands.arrived)
  return _impl_.arrived_;
}

// repeated .U2ADelivering delivering = 2;
inline int UPSCommands::_internal_delivering_size() const {
  return _impl_.delivering_.size();
}
inline int UPSCommands::delivering_size() const {
  return _internal_delivering_size();
}
inline void UPSCommands::clear_delivering() {
  _impl_.delivering_.Clear();
}
inline ::U2ADelivering* UPSCommands::mutable_delivering(int index) {
  // @@protoc_insertion_point(field_mutable:UPSCommands.delivering)
  return _impl_.delivering_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ADelivering >*
UPSCommands::mutable_delivering() {
  // @@protoc_insertion_point(field_mutable_list:UPSCommands.delivering)
  return &_impl_.delivering_;
}
inline const ::U2ADelivering& UPSCommands::_internal_delivering(int index) const {
  return _impl_.delivering_.Get(index);
}
inline const ::U2ADelivering& UPSCommands::delivering(int index) const {
  // @@protoc_insertion_point(field_get:UPSCommands.delivering)
  return _internal_delivering(index);
}
inline ::U2ADelivering* UPSCommands::_internal_add_delivering() {
  return _impl_.delivering_.Add();
}
inline ::U2ADelivering* UPSCommands::add_delivering() {
  ::U2ADelivering* _add = _internal_add_delivering();
  // @@protoc_insertion_point(field_add:UPSCommands.delivering)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ADelivering >&
UPSCommands::delivering() const {
  // @@protoc_insertion_point(field_list:UPSCommands.delivering)
  return _impl_.delivering_;
}

// repeated .U2ADelivered delivered = 3;
inline int UPSCommands::_internal_delivered_size() const {
  return _impl_.delivered_.size();
}
inline int UPSCommands::delivered_size() const {
  return _internal_delivered_size();
}
inline void UPSCommands::clear_delivered() {
  _impl_.delivered_.Clear();
}
inline ::U2ADelivered* UPSCommands::mutable_delivered(int index) {
  // @@protoc_insertion_point(field_mutable:UPSCommands.delivered)
  return _impl_.delivered_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ADelivered >*
UPSCommands::mutable_delivered() {
  // @@protoc_insertion_point(field_mutable_list:UPSCommands.delivered)
  return &_impl_.delivered_;
}
inline const ::U2ADelivered& UPSCommands::_internal_delivered(int index) const {
  return _impl_.delivered_.Get(index);
}
inline const ::U2ADelivered& UPSCommands::delivered(int index) const {
  // @@protoc_insertion_point(field_get:UPSCommands.delivered)
  return _internal_delivered(index);
}
inline ::U2ADelivered* UPSCommands::_internal_add_delivered() {
  return _impl_.delivered_.Add();
}
inline ::U2ADelivered* UPSCommands::add_delivered() {
  ::U2ADelivered* _add = _internal_add_delivered();
  // @@protoc_insertion_point(field_add:UPSCommands.delivered)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2ADelivered >&
UPSCommands::delivered() const {
  // @@protoc_insertion_point(field_list:UPSCommands.delivered)
  return _impl_.delivered_;
}

// repeated .U2AShipStatus status = 4;
inline int UPSCommands::_internal_status_size() const {
  return _impl_.status_.size();
}
inline int UPSCommands::status_size() const {
  return _internal_status_size();
}
inline void UPSCommands::clear_status() {
  _impl_.status_.Clear();
}
inline ::U2AShipStatus* UPSCommands::mutable_status(int index) {
  // @@protoc_insertion_point(field_mutable:UPSCommands.status)
  return _impl_.status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2AShipStatus >*
UPSCommands::mutable_status() {
  // @@protoc_insertion_point(field_mutable_list:UPSCommands.status)
  return &_impl_.status_;
}
inline const ::U2AShipStatus& UPSCommands::_internal_status(int index) const {
  return _impl_.status_.Get(index);
}
inline const ::U2AShipStatus& UPSCommands::status(int index) const {
  // @@protoc_insertion_point(field_get:UPSCommands.status)
  return _internal_status(index);
}
inline ::U2AShipStatus* UPSCommands::_internal_add_status() {
  return _impl_.status_.Add();
}
inline ::U2AShipStatus* UPSCommands::add_status() {
  ::U2AShipStatus* _add = _internal_add_status();
  // @@protoc_insertion_point(field_add:UPSCommands.status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2AShipStatus >&
UPSCommands::status() const {
  // @@protoc_insertion_point(field_list:UPSCommands.status)
  return _impl_.status_;
}

// repeated .U2AChangeAddress address = 5;
inline int UPSCommands::_internal_address_size() const {
  return _impl_.address_.size();
}
inline int UPSCommands::address_size() const {
  return _internal_address_size();
}
inline void UPSCommands::clear_address() {
  _impl_.address_.Clear();
}
inline ::U2AChangeAddress* UPSCommands::mutable_address(int index) {
  // @@protoc_insertion_point(field_mutable:UPSCommands.address)
  return _impl_.address_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2AChangeAddress >*
UPSCommands::mutable_address() {
  // @@protoc_insertion_point(field_mutable_list:UPSCommands.address)
  return &_impl_.address_;
}
inline const ::U2AChangeAddress& UPSCommands::_internal_address(int index) const {
  return _impl_.address_.Get(index);
}
inline const ::U2AChangeAddress& UPSCommands::address(int index) const {
  // @@protoc_insertion_point(field_get:UPSCommands.address)
  return _internal_address(index);
}
inline ::U2AChangeAddress* UPSCommands::_internal_add_address() {
  return _impl_.address_.Add();
}
inline ::U2AChangeAddress* UPSCommands::add_address() {
  ::U2AChangeAddress* _add = _internal_add_address();
  // @@protoc_insertion_point(field_add:UPSCommands.address)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::U2AChangeAddress >&
UPSCommands::address() const {
  // @@protoc_insertion_point(field_list:UPSCommands.address)
  return _impl_.address_;
}

// repeated .Error error = 6;
inline int UPSCommands::_internal_error_size() const {
  return _impl_.error_.size();
}
inline int UPSCommands::error_size() const {
  return _internal_error_size();
}
inline void UPSCommands::clear_error() {
  _impl_.error_.Clear();
}
inline ::Error* UPSCommands::mutable_error(int index) {
  // @@protoc_insertion_point(field_mutable:UPSCommands.error)
  return _impl_.error_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Error >*
UPSCommands::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:UPSCommands.error)
  return &_impl_.error_;
}
inline const ::Error& UPSCommands::_internal_error(int index) const {
  return _impl_.error_.Get(index);
}
inline const ::Error& UPSCommands::error(int index) const {
  // @@protoc_insertion_point(field_get:UPSCommands.error)
  return _internal_error(index);
}
inline ::Error* UPSCommands::_internal_add_error() {
  return _impl_.error_.Add();
}
inline ::Error* UPSCommands::add_error() {
  ::Error* _add = _internal_add_error();
  // @@protoc_insertion_point(field_add:UPSCommands.error)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Error >&
UPSCommands::error() const {
  // @@protoc_insertion_point(field_list:UPSCommands.error)
  return _impl_.error_;
}

// repeated int64 acks = 7;
inline int UPSCommands::_internal_acks_size() const {
  return _impl_.acks_.size();
}
inline int UPSCommands::acks_size() const {
  return _internal_acks_size();
}
inline void UPSCommands::clear_acks() {
  _impl_.acks_.Clear();
}
inline int64_t UPSCommands::_internal_acks(int index) const {
  return _impl_.acks_.Get(index);
}
inline int64_t UPSCommands::acks(int index) const {
  // @@protoc_insertion_point(field_get:UPSCommands.acks)
  return _internal_acks(index);
}
inline void UPSCommands::set_acks(int index, int64_t value) {
  _impl_.acks_.Set(index, value);
  // @@protoc_insertion_point(field_set:UPSCommands.acks)
}
inline void UPSCommands::_internal_add_acks(int64_t value) {
  _impl_.acks_.Add(value);
}
inline void UPSCommands::add_acks(int64_t value) {
  _internal_add_acks(value);
  // @@protoc_insertion_point(field_add:UPSCommands.acks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
UPSCommands::_internal_acks() const {
  return _impl_.acks_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
UPSCommands::acks() const {
  // @@protoc_insertion_point(field_list:UPSCommands.acks)
  return _internal_acks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
UPSCommands::_internal_mutable_acks() {
  return &_impl_.acks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
UPSCommands::mutable_acks() {
  // @@protoc_insertion_point(field_mutable_list:UPSCommands.acks)
  return _internal_mutable_acks();
}

// optional bool finish = 8;
inline bool UPSCommands::_internal_has_finish() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UPSCommands::has_finish() const {
  return _internal_has_finish();
}
inline void UPSCommands::clear_finish() {
  _impl_.finish_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool UPSCommands::_internal_finish() const {
  return _impl_.finish_;
}
inline bool UPSCommands::finish() const {
  // @@protoc_insertion_point(field_get:UPSCommands.finish)
  return _internal_finish();
}
inline void UPSCommands::_internal_set_finish(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.finish_ = value;
}
inline void UPSCommands::set_finish(bool value) {
  _internal_set_finish(value);
  // @@protoc_insertion_point(field_set:UPSCommands.finish)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ups_5famazon_2eproto
